# vim: set syn=sh noet:
set +x
declare -A | grep -wq colors || source $initDir/.colors
test "$debug" '>' 0 && echo "=> Running $bold${colors[blue]}$(basename ${BASH_SOURCE[0]})$normal ..."

\which ffmpeg  >/dev/null 2>&1 && ffmpeg="command  ffmpeg  -hide_banner" &&  ffmpegOptions="-probesize 400M -analyzeduration 400M"
\which ffprobe >/dev/null 2>&1 && ffprobe="command ffprobe -hide_banner" && ffprobeOptions="-probesize 400M -analyzeduration 400M"
\which youtube-dl >/dev/null 2>&1 && youtube_dl="eval LANG=C.UTF-8 command youtube-dl"

remuxOptions="-map 0 -c copy"
mp4Options="-movflags +frag_keyframe"
mp4RemuxOptions="-map 0 -c copy -c:s mov_text"
aac2m4aOptions="-bsf:a aac_adtstoasc"
cdr_device=/dev/dvd

[ $BASH_VERSINFO -ge 4 ] && declare -A audioExtension videoExtension audioDecode
audioExtension=( [libspeex]=oga [speex]=oga [opus]=opus [vorbis]=ogg [aac]=m4a [mp3]=mp3 [mp2]=mp2 [ac3]=ac3 [wmav2]=wma [pcm_dvd]=wav [pcm_s16le]=wav )
videoExtension=( [h264]=m4v [mpeg1video]=mpg [mpeg2video]=vob [mpeg4]=avi [flv1]=flv [wmv3]=wmv )
audioDecode=( [libspeex]=$(which speexdec 2>/dev/null) [speex]=$(which speexdec 2>/dev/null) [opus]=$(which opusdec 2>/dev/null) [vorbis]=$(which oggdec 2>/dev/null) )

alias mp32wavstdout="\mpg123 --wav - "
alias ogg2wavstdout="\oggdec --output=- "

function urlOfVideo {
	local extension
	for video
	do
		extension=${video/*./}
		case $extension in
		mp4|m4a|m4b|m4v) tag=description;;
		webm|mkv) tag=purl;;
		*) echo "=> The $extension is not supported yet." >&2 && continue;;
		esac
		echo "=> video = $video"
		$ffprobe -v error -show_entries format_tags=$tag -of default=noprint_wrappers=1:nokey=1 "$video"
	done
}
function addSubtitles2mp4 {
	local inputVideo=$1
	test $# -le 1 && {
		echo "=> Usage: $FUNCNAME inputVideo subFile1 subFile2 subFile3 ..." >&2
		return 1
	}

	local outputVideo=${inputVideo/.mp4/_NEW.mp4}
	shift
	local numberOfSubtitles=$#
	(printf "ffmpeg -hide_banner -i $inputVideo ";printf -- "-i %s " "$@";printf -- "-map %d " $(seq $numberOfSubtitles);printf -- "-map 0:a -map 0:v -c copy -c:s mov_text $outputVideo\n") | sh -x
	local codeRet=$?
	sync
	sleep 1
	touch -r "$inputVideo" "$outputVideo"
	[ $codeRet = 0 ] && echo && \mv -vf "$outputVideo" "$inputVideo"
}
function addThumbnail2mp4 {
	local artworkFile=$1
	shift
	for mpeg
	do
		AtomicParsley "$mpeg" --artwork "$artworkFile" --overWrite
	done
}
alias addCover2mp4=addThumbnail2mp4
function videoURL {
	for video
	do
		printf "$video : "
		$ffprobe "$video" 2>&1 | awk '/PURL|description/{print$3;exit;}'
	done
}
function addURL2Audio_Video {
	local url=$1
	local fileName=$2
	extension=${fileName/*./}
#	$ffmpeg -i "$fileName" -c copy -metadata description="$url" "${fileName%.*}-NEW.$extension" && mv -vf "${fileName%.*}-NEW.$extension" $fileName
	[ $extension = mp4 ] || [ $extension = m4a ] && mp4tags -m "$url" "$fileName"
	sync
}
function videoRotateLeft {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -c copy -metadata:s:v:0 rotate=90 "${video%.*}-ROTATED.$extension"
	done
}
function videoRotateRight {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -c copy -metadata:s:v:0 rotate=-90 "${video%.*}-ROTATED.$extension"
	done
}
function mkvInfo {
#	file="$1"
#	shift
#	time time mkvinfo -s "$file" | grep Track
	for file
	do
		echo "=> file = $file" >&2
		echo >&2
		time mkvinfo -s "$file" 
		echo >&2
	done | grep Track
}
function mp32opus {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" $@ "${file%.*}.opus"
	for file
	do
		time $ffmpeg -i "$file" "${file%.*}.opus"
		touch -r "$file" "${file%.*}.opus"
		sync
	done
}
function audioDelay {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME video delay" >&2
		return 1
	}

	local video=$1
	local delay=$2
	local extension=${video/*./}
	time $ffmpeg -i "$video" -itsoffset $delay -i "$video" -c copy -map 0:v -map 1:a "${video%.*}-FIXED.$extension" #cf. https://superuser.com/questions/982342/in-ffmpeg-how-to-delay-only-the-audio-of-a-mp4-video-without-converting-the-au/983153#983153
}
function videoDelay {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME video delay" >&2
		return 1
	}

	local video=$1
	local delay=$2
	local extension=${video/*./}
	time $ffmpeg -i "$video" -itsoffset $delay -i "$video" -c copy -map 1:v -map 0:a "${video%.*}-FIXED.$extension" #cf. https://superuser.com/questions/982342/in-ffmpeg-how-to-delay-only-the-audio-of-a-mp4-video-without-converting-the-au/983153#983153
}
function audio2Video4YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME aacFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	local audioCodec=$(audioCodecOfFile $audio)
	local video4YouTubeFile
	case $audioCodec in
	aac)video4YouTubeFile="${audio%.*}__4YouTube.mp4"
		time $ffmpeg -i "$audio" -loop 1 -framerate 4 -i "$picture" -shortest -speed max -map 0:a -c:a copy -map 1:v -preset medium -tune stillimage -crf 18 -pix_fmt yuv420p -movflags +frag_keyframe "$video4YouTubeFile" #cf. https://trac.ffmpeg.org/wiki/Encode/YouTube
		;;
	opus|vorbis)video4YouTubeFile="${audio%.*}__4YouTube.webm"
		time $ffmpeg -i "$audio" -loop 1 -framerate 1 -i "$picture" -shortest -speed max -map 0:a -c:a copy -map 1:v "$video4YouTubeFile"
		;;
	*) echo "=> ERROR : $FUNCNAME : $audioCodec is not supported yet." >&2;return 1 ;;
	esac
	videoInfo "$video4YouTubeFile"
}
function aac2MP44YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME aacFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	time $ffmpeg -i "$audio" -loop 1 -framerate 4 -i "$picture" -shortest -speed max -c:a copy -preset medium -tune stillimage -crf 18 -pix_fmt yuv420p -movflags +frag_keyframe "${audio%.*}.mp4" #cf. https://trac.ffmpeg.org/wiki/Encode/YouTube
}
function opus2WebM4YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME opusFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	time $ffmpeg -i "$audio" -loop 1 -framerate 1 -i "$picture" -shortest -speed max -c:a copy "${audio%.*}.webm"
}
function frameCount {
	for video
	do
		echo "Video : $video"
		printf "Frames : "
		mediainfo --Inform="Video;%FrameCount%" "$video"
		echo
	done
}
function to16_9 {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -aspect 16/9 $remuxOptions "${video/.$extension/_16_9eme.$extension}"
	done
}
function moov_atomFix {
	for inputFile
	do
		echo "=> inputFile = <$inputFile>" >&2
		outputFile="${inputFile/.mp4/_moov_atom_FIXED.mp4}"
		qtfaststart "$inputFile" "$outputFile" && touch -r "$inputFile" "$outputFile" && echo "=> outputFile = <$outputFile>" >&2
		sync
	done
}
function cropdetect {
	ffmpeg -i "$1" -t 1 -vf cropdetect -f null - 2>&1 | awk '/crop/{line=$NF}END{print line}'
}
function dvdinfo {
	cdr_device=/dev/dvd
	longestTrack=$(\lsdvd -Oy | awk -F ':|,| ' '/longest_track/{print$(NF-1)}')
	tccat -i $cdr_device -T $longestTrack,-1 2>/dev/null | $ffprobe - 2>&1
}
function mp4Info {
	for file
	do
		echo "=> file = <$file>"
		AtomicParsley "$file" -T 1 | sed '/Movie duration/,$!d'
	done
}
function addChaptersToMP4 {
	for file
	do
		MP4Box -chap "${file/.mp4/.chapters}" -add "$file" -new OUTPUT.mp4
	done
	sync
}
function addChaptersToM4A {
	for file
	do
		MP4Box -chap "${file/.m4a/.chapters}" -add "$file" -new OUTPUT.m4a
		\mv -v OUTPUT.m4a OUTPUT.m4b
	done
	sync
}
function urlinfo {
	for url
	do
		echo "=> url = $url"
		$ffprobe $($youtube_dl -gf best -- "$url")
	done
}
function audioChannelsLayoutOfFile {
	local file="$1"
	local layout=$($ffprobe "$file" -select_streams a:0 -show_entries stream=channel_layout -of default=noprint_wrappers=1:nokey=1 -v error)
	echo $layout
}
function audioCodecOfFile {
	local file="$1"
	local codec=$($ffprobe "$file" -select_streams a:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
	echo $codec
}
function videoCodecOfFile {
	local file="$1"
	local codec=$($ffprobe "$file" -select_streams v:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
	echo $codec
}
function any2wavSTDOUT {
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>" >&2
		time $ffmpeg -i "$inputFile" -vn -sn -f wav -
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2wav {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.wav"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any216kHzopus {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | sox -V -t wav - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus64kbps {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - --bitrate 64 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus42kbps {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - --bitrate 42 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus32kbps {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - --bitrate 32 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2m4a {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.m4a"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -acodec aac -aprofile aac_low -q:a 1 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2m4a_HE_AAC_VBR {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}_HE-AAC.m4a"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he -vbr 1 "$outputFile"
			else
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he_v2 -vbr 1 "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2aac {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.aac"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -acodec aac -aprofile aac_low -q:a 1 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2aac_HE_AAC_VBR {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}_HE-AAC.aac"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he -vbr 1 "$outputFile"
			else
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he_v2 -vbr 1 "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function mp42mp4_HE_AAC_CBR {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile=${inputFile/.mp4/_HE-AAC.mp4}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" $remuxOptions -acodec libfdk_aac -aprofile aac_he    -ab 64k $mp4Options "$outputFile"
			else
				time $ffmpeg -i "$inputFile" $remuxOptions -acodec libfdk_aac -aprofile aac_he_v2 -ab 64k $mp4Options "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function spx216kHzopus {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if [ $(audioChannelsLayoutOfFile "$inputFile") = stereo ]
			then
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 2 - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			else
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 1 - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			fi
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function spx216kHzspx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.oga/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q stereo
			then
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 2 - -t wav - channels 1 rate 16k norm | speexenc -V --quality 10 --vbr - "$outputFile"
			else
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 1 - -t wav - channels 1 rate 16k norm | speexenc -V --quality 10 --vbr - "$outputFile"
			fi
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function spx2opus {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			#freq=$(mediainfo --Inform="Audio;%SamplingRate%" "$inputFile")
			time audio2stout "$inputFile" | opusenc - "$outputFile"
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function audio2stout {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		$ffmpeg -i "$inputFile" -f wav -
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp32spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		title=$(mp3info2 -p %t "$inputFile")
		echo "==> title = <$title>"
		album=$(mp3info -p %l "$inputFile")
		echo "==> album = <$album>"
#		artist=$(mp3info -p %a "$inputFile")

		outputFile=${inputFile/.mp3/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time sox -V "$inputFile" -t wav - channels 1 rate 16k norm | speexenc --title "$title" --comment ALBUM="$album" -V --vbr --quality 10 - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav216kwav {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_16kHz.wav}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -ar 16k "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav2spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
#			time sox -V "$inputFile" -r 16k $namedPipe norm &
			time sox -V "$inputFile" $namedPipe rate 16k norm &
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr $namedPipe "$outputFile"
			time speexenc -V --quality 10 --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function flac2spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.flac/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
#			time sox -V "$inputFile" -r 16k $namedPipe norm &
#			time sox -V "$inputFile" $namedPipe rate 16k norm &
			time $ffmpeg -i "$inputFile" -ar 16k $namedPipe -y &
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr $namedPipe "$outputFile"
			time speexenc -V --quality 10 --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav16k2spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile=${inputFile/.wav/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr "$inputFile" "$outputFile"
			time speexenc -V --quality 10 --vbr "$inputFile" "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav2opus {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
			time sox -V "$inputFile" $namedPipe rate 16k norm &
#			time opusenc --title "$title" --album ALBUM="$album" --vbr $namedPipe "$outputFile"
			time opusenc --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function _16kwav16k2opus {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time opusenc --title "$title" --album ALBUM="$album" --vbr "$inputFile" "$outputFile"
			time opusenc --vbr "$inputFile" "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav216kHz {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_16k.wav}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time sox -V "$inputFile" "$outputFile" rate 16k norm
			time $ffmpeg -i "$inputFile" -ar 16k "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function webmAudio2ogg {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.webm/.ogg}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp4DashAudio2m4a {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.mp4/.m4a}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp4DashAudio2aac {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.mp4/.aac}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function m3uConcat {
	files="$@"
	echo "#EXTM3U"
	egrep -hv "EXTM3U|^# *$" $files | dos2unix | egrep -v "^$"
}
function videoSplit {
	if [ $# != 2 ] && [ $# != 3 ]
	then
		echo "=> Usage: $FUNCNAME <filename> hh:mm:ss[.xxx] [ hh:mm:ss[.xxx] ]" >&2
		return 1
	fi

	fileName="$1"
	test -r "$fileName" || {
		echo "=> ERROR: <$fileName> cannot be read by $USER or does not exist." >&2
		return 2
	}

	extension=${fileName/*./}
	fileBaseName=${fileName%.???}
	begin=$2
	outputFile="$fileBaseName-CUT.$extension"
	chmod -x "$fileName"

#	[ $extension = mp4 ] && remuxOptions="$remuxOptions $mp4Options"
	if test $# = 3
	then
		end=$3
		duration=$(echo $(date +%s.%N -d $end) - $(date +%s.%N -d $begin) | bc -l)
		set -x
		time $ffmpeg -ss $begin -t $duration -i "$fileName" $remuxOptions "$outputFile"
	else
		set -x
		time $ffmpeg -ss $begin -i "$fileName" $remuxOptions "$outputFile"
	fi
	set +x
	sync
	touch -r "$fileName" "$outputFile"
	echo "=> outputFile = <$outputFile>"
}
function audioShift {
	if [ $# != 2 ] && [ $# != 3 ]; then
		echo "=> Usage: $FUNCNAME <filename> hh:mm:ss[.xxx]"
		return 1
	fi

	fileName="$1"
	extension=${fileName/*./}
	fileBaseName=${fileName%.???}
	shift=$2
	time $ffmpeg -itsoffset $shift -i "$fileName" $remuxOptions "$fileBaseName-SHIFTED.$extension"
	sync
	touch -r "$fileName" "$fileBaseName-SHIFTED.$extension"
}
function sizeofStream {
	local size
	local total="0"
	local format=fmt18_360p
	echo $1 | grep -q ^http || {
	format=$1
	shift
	}
	for url in "$@"
	do
		size=$(curl -sI "$($youtube_dl -gf best -- "$url")" | awk 'BEGIN{IGNORECASE=1}/Content-Length:/{print$2/2^20}')
		total="$total+$size"
		printf "%s %s Mo\n" $url $size
	done
	total=$(echo $total | \bc -l)
	echo "=> total = $total Mo"
}
function vlcRecord {
	local file=vlc-record-$(date +"%Y-%m-%d-%Hh%Mm%Ss")-$(echo $1 | tr "[:/]" "_" ).ts
	echo "=> The recording will be saved into the file: <$file>"
	cvlc --verbose=1 --ipv4-timeout=600  --logmode=text --log-verbose=-1 --logfile=vlcrecord_$(date +"%Y-%m-%d-%Hh%Mm%Ss").out --sout=file:$file $1
	echo "=> The recording is saved into the file: <$file>" >&2
}

#function aacDir2mp3 { inp=aac; shopt -s globstar && time for f in **/*.$inp; do time avconv -i "$f" "${f/.$inp/.mp3}" && rm -v "$f"; done; }
function aacDir2mp3 { shopt -s globstar && for f in **/*.aac; do /bin/mv -vi "$f" "${f/.aac/.m4a}"; done; time pacpl -v --eopts "-v" -r -k -t mp3 .; }
function audioGet {
	ls "$@" >/dev/null || return
	declare -A audioExtension=( [libspeex]=oga [speex]=oga [opus]=opus [vorbis]=ogg [aac]=m4a [mp3]=mp3 [mp2]=mp2 [ac3]=ac3 [wmav2]=wma [pcm_dvd]=wav [pcm_s16le]=wav )
	for file
	do
		extension=${file/*./}
		audioCodec=$(audioCodecOfFile "$file")
		outputExtension=${audioExtension[$audioCodec]}
		outputFileName=${file/.$extension/_AUDIO.$outputExtension}
		outputFileName=$(echo $outputFileName | cut -d/ -f3-) # Remove the two leading directories from the path
		minimumAudioStreamSize=$(mediainfo --Output="Audio;%StreamSize%" "$file") || return
		if test -s "$outputFileName" && [ $(stat -c '%s' "$outputFileName") -ge $minimumAudioStreamSize ]
		then
			echo "=> INFO: The file $file has already been converted to $outputFileName." >&2
			continue
		fi
		\mkdir -pv $(dirname $outputFileName)
		if [ $outputExtension = aac ];then
			time $ffmpeg -i "$file" -map 0 -map -0:v -codec copy "$outputFileName" -y
		else
			time $ffmpeg -i "$file" -map 0 -map -0:v:0 -codec copy "$outputFileName" -y
		fi
		touch -r "$file" "$outputFileName"
		sync
		echo
		test -s "$outputFileName" && echo "=> Output file is: <$outputFileName>."
	done
}
function videoGet {
	ls "$@" >/dev/null || return
	for file
	do
		extension=${file/*./}
		videoFormat=$(ffprobe "$file" 2>&1 | grep -v Video:.mjpeg | awk '/Video/{print$4}' | sed "s/,$//")
		outputExtension=${videoExtension[$videoFormat]}
		outputFileName=${file/.$extension/_VIDEO.$outputExtension}
		outputFileName=$(echo $outputFileName | cut -d/ -f3-) # Remove the two leading directories from the path
		minimumVideoStreamSize=$(mediainfo --Output="Video;%StreamSize%" "$file") || return
		if test -s "$outputFileName" && [ $(stat -c '%s' "$outputFileName") -ge $minimumVideoStreamSize ]
		then
			echo "=> INFO: The file $file has already been converted to $outputFileName." >&2
			continue
		fi
		\mkdir -pv $(dirname $outputFileName)
		time $ffmpeg -i "$file" -an -codec copy $options "$outputFileName" -y
		touch -r "$file" "$outputFileName"
		sync
		echo
		test -s "$outputFileName" && echo "=> Output file is: <$outputFileName>."
	done
}
function avprobe {
	for arg
	do
		echo "$arg" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $avprobe $avprobeOptions "$($youtube_dl -gf best -- "$arg")" || command avprobe $avprobeOptions -probesize 400M -analyzeduration 400M "$arg"
#	done 2>&1 | cut -c 1-$COLUMNS
	done
}
function videoInfo {
	local columns=$COLUMNS
#	local columns="" # To see more info than the width of the screen
	local size=0
	which ffprobe >/dev/null && {
		for urlOrFile
		do
			echo "=> urlOrFile = $urlOrFile"
			if echo "$urlOrFile" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://"
			then
				#remote stream
				if \curl -s "$urlOrFile" | file -bi - | \grep -q "^text/"
				then
					echo "=> This stream needs first to be resolved by youtube-dl ..."
					possibleFormats=best[ext=mp4]/best[ext=webm]/best[ext=flv]/18/webm/sd/http-480
					infos="$($youtube_dl -gef $possibleFormats -- "$urlOrFile")"
					test -z "$infos" && continue
					title="$(echo "$infos" | sed -n 1p )"
					directURLOfStream="$(echo "$infos" | sed -n 2p | sed "s/ /%20/g")"
					size=$(\curl -sI "$directURLOfStream" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Title: $title"
					echo "Size: $size"
					command ffprobe $ffprobeOptions "$directURLOfStream" 2>&1
				else
					#direct stream
					echo "=> This stream is direct stream"
					size=$(\curl -sI "$urlOrFile" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Size: $size"
					$ffprobe "$urlOrFile"
				fi
			else
				echo "=> The file is local to this machine."
				#Local file
				size=$(\ls -l "$urlOrFile" | awk '/[0-9]+/{printf "%8.3f MiB\n",$5/1024^2}')
				echo "Size: $size"
				$ffprobe "$urlOrFile" || $ffprobe $ffprobeOptions "$urlOrFile"
			fi
			echo
		done 2>&1 | \egrep -vi "^ +(:|comment|description +: [^/]+$)" | uniq | egrep -iw "^$|description.*:/|PURL.*:/|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
	}
}
function videoInfoOLD {
	local columns=$COLUMNS
#	local columns="" # To see more info than the width of the screen
	local size=0
	which ffprobe >/dev/null && {
		for urlOrFile
		do
			echo "=> urlOrFile = $urlOrFile"
			if echo "$urlOrFile" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://"
			then
				#remote stream
				if \curl -s "$urlOrFile" | file -bi - | \grep -q "^text/"
				then
					echo "=> This stream needs first to be resolved by youtube-dl ..."
					possibleFormats=best[ext=mp4]/best[ext=webm]/best[ext=flv]/18/webm/sd/http-480
					infos="$($youtube_dl -gef $possibleFormats -- "$urlOrFile")"
					test -z "$infos" && continue
					title="$(echo "$infos" | sed -n 1p )"
					directURLOfStream="$(echo "$infos" | sed -n 2p)"
					size=$(\curl -sI "$directURLOfStream" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Title: $title"
					echo "Size: $size"
					command ffprobe $ffprobeOptions "$directURLOfStream" 2>&1
				else
					#direct stream
					echo "=> This stream is direct stream"
					size=$(\curl -sI "$urlOrFile" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Size: $size"
					$ffprobe "$urlOrFile"
				fi
			else
				echo "=> The file is local to this machine."
				#Local file
				size=$(\ls -l "$urlOrFile" | awk '/[0-9]+/{printf "%8.3f MiB\n",$5/1024^2}')
				echo "Size: $size"
				$ffprobe "$urlOrFile" || $ffprobe $ffprobeOptions "$urlOrFile"
			fi
			echo
#		done 2>&1 | cut -c 1-$columns | \egrep -iw "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not" | uniq | \egrep -iw --color "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
		done 2>&1 | \egrep -iw "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not" | uniq | \egrep -iw --color "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
	}
}
function mediainfoSummary {
	for media
	do
		mediainfo "$media"
		echo
	done | \egrep "^($|Complete name|Width|Height|Encoding settings|Format  |Format version|Format profile|Duration|Video|Audio|Text|Menu|Language)| size|Kbps|[Bb]it ?rate"
}
function ffprobe {
	which ffprobe >/dev/null && {
		for arg
		do
			echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$($youtube_dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
		done 2>&1
	}
}
function ffprobeFlat {
	local ffprobeOptions="-v error -show_format -show_streams -of flat"
	for arg
	do
		echo "$arg" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$($youtube_dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$COLUMNS
}
function ffprobeIni {
	local ffprobeOptions="-v error -show_format -show_streams -of ini"
	for arg
	do
		echo "$arg" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$($youtube_dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$COLUMNS
}
function ffprobeJSON {
	local ffprobeOptions="-v error -show_format -show_streams -of json"
	for arg
	do
		echo "$arg" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$($youtube_dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$COLUMNS
}
function ffprobeXML {
	local ffprobeOptions="-v error -show_format -show_streams -of xml"
	for arg
	do
		echo "$arg" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$($youtube_dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$COLUMNS
}
function mp4Repair {
	for file
	do
		extension=mp4
		time $ffmpeg -i "$file" $remuxOptions $mp4Options "${file/.$extension/_REPAIRED.$extension}"
		sync
		touch -r "$file" "${file/.$extension/_REPAIRED.$extension}"
	done
}
function videoRepair {
	for file
	do
		extension="${file/*./}"
		time $ffmpeg -i "$file" $remuxOptions "${file/.$extension/_REPAIRED.$extension}"
		sync
		touch -r "$file" "${file/.$extension/_REPAIRED.$extension}"
	done
}
function videoRemux {
	local inputFile="$1"
	if [ $# != 2 ]
	then
		echo "=> Usage: $FUNCNAME inputFileName outputFileName [ffmpegCLIParameters]" >&2
		exit 1
	fi

	shift
	outputFile="$1"
	outputExtension=${outputFile/*./}
	local options
	case $outputExtension in
		vob) options="-f mpeg" ;;
		*) options="" ;;
	esac

	time $ffmpeg -i "$inputFile" $remuxOptions $options "$@"
	sync
	touch -r "$inputFile" "$outputFile"
}
function aac2m4a {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -acodec copy $aac2m4aOptions $@ "${file/.aac/.m4a}"
	for file
	do
		time $ffmpeg -i "$file" -acodec copy $aac2m4aOptions "${file/.aac/.m4a}"
		touch -r "$file" "${file/.aac/.m4a}"
		sync
	done
}
function m4a2aac {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -acodec copy $@ "${file/.m4a/.aac}"
	for file
	do
		time $ffmpeg -i "$file" -acodec copy "${file/.m4a/.aac}"
		touch -r "$file" "${file/.m4a/.aac}"
		sync
	done
}
function mkv2oga {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -vn -acodec copy $@ "${file/.mkv/.oga}"
	for file
	do
		time $ffmpeg -i "$file" -vn -acodec copy "${file/.mkv/.oga}"
		touch -r "$file" "${file/.mkv/.oga}"
		sync
	done
}

set +x
test "$debug" '>' 0 && echo "=> END of $bold${colors[blue]}$(basename ${BASH_SOURCE[0]})$normal"
