# vim: set ft=sh noet:
set +x

! declare 2>&1 | grep -wq ^colors= && [ $BASH_VERSINFO -ge 4 ] && source $initDir/.colors
test "$debug" -gt 0 && echo "=> Running $bold${colors[blue]}$(basename ${BASH_SOURCE[0]})$normal ..."

test "$debug" -gt 0 && Echo "\n=> \${BASH_SOURCE[*]} = ${BASH_SOURCE[*]}\n"

type -P ffmpeg  >/dev/null 2>&1 && ffmpeg="command  ffmpeg"  && ffmpegOptions="-probesize 400M -analyzeduration 400M"
type -P ffplay  >/dev/null 2>&1 && ffplay="command ffplay"   && ffplayOptions="$ffmpegOptions"
type -P ffprobe >/dev/null 2>&1 && ffprobe="command ffprobe" && ffprobeOptions="$ffmpegOptions"

#youtube_dl="eval LANG=C.UTF-8 command youtube-dl" # i.e https://unix.stackexchange.com/questions/505733/ # eval A EVITER

remuxOptions="-map 0 -c copy"
mp4Options="-movflags +frag_keyframe"
mp4RemuxOptions="-map 0 -c copy -c:s mov_text"
aac2m4aOptions="-bsf:a aac_adtstoasc"
cdr_device=/dev/dvd

[ $BASH_VERSINFO -ge 4 ] && declare -Ag audioExtension videoExtension audioDecode # i.e https://unix.stackexchange.com/a/535721/135038
audioExtension=( [libspeex]=spx [speex]=spx [opus]=opus [vorbis]=ogg [aac]=m4a [mp3]=mp3 [mp2]=mp2 [ac3]=ac3 [wmav2]=wma [pcm_dvd]=wav [pcm_s16le]=wav )
videoExtension=( [h264]=m4v [mpeg1video]=mpg [mpeg2video]=vob [mpeg4]=avi [flv1]=flv [wmv3]=wmv )
audioDecode=( [libspeex]=speexdec [speex]=speexdec [opus]=opusdec [vorbis]=oggdec )

#function aacDir2mp3 { inp=aac; shopt -s globstar && time for f in **/*.$inp; do time avconv -i "$f" "${f/.$inp/.mp3}" && rm -v "$f"; done; }
function _16kwav16k2opus {
	local inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time opusenc --title "$title" --album ALBUM="$album" --vbr "$inputFile" "$outputFile"
			time opusenc --vbr "$inputFile" "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function aac2MP44YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME aacFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	time $ffmpeg -i "$audio" -loop 1 -framerate 4 -i "$picture" -shortest -speed max -c:a copy -preset medium -tune stillimage -crf 18 -pix_fmt yuv420p -movflags +frag_keyframe "${audio%.*}.mp4" #cf. https://trac.ffmpeg.org/wiki/Encode/YouTube
	sync
}
function aac2m4a {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -acodec copy $aac2m4aOptions $@ "${file/.aac/.m4a}"
	for file
	do
		time $ffmpeg -i "$file" -acodec copy $aac2m4aOptions "${file/.aac/.m4a}"
		touch -r "$file" "${file/.aac/.m4a}"
		sync
	done
}
function aacDir2mp3 { shopt -s globstar && for f in **/*.aac; do /bin/mv -vi "$f" "${f/.aac/.m4a}"; done; time pacpl -v --eopts "-v" -r -k -t mp3 .; }
function audioGet {
#	ls "$@" >/dev/null || return
	for file
	do
		extension=${file/*./}
		audioCodec=$(audioCodecOfFile "$file" 2>/dev/null)
		outputExtension=${audioExtension[$audioCodec]}
		outputFileName=${file/.$extension/_AUDIO.$outputExtension}
		outputFileName=$(echo $outputFileName | cut -d/ -f3-) # Remove the two leading directories from the path
		minimumAudioStreamSize=$(mediainfo --Output="Audio;%StreamSize%" "$file") || return
		if test -s "$outputFileName" && [ $(stat -c '%s' "$outputFileName") -ge $minimumAudioStreamSize ]
		then
			echo "=> INFO: The file $file has already been converted to $outputFileName." >&2
			continue
		fi
		\mkdir -pv $(dirname $outputFileName)
		if [ $outputExtension = aac ];then
			time $ffmpeg -i "$file" -map 0 -map -0:v -codec copy "$outputFileName" -y
		else
			time $ffmpeg -i "$file" -map 0 -map -0:v:0 -codec copy "$outputFileName" -y
		fi
		touch -r "$file" "$outputFileName"
		sync
		echo
		test -s "$outputFileName" && echo "=> Output file is: <$outputFileName>."
	done
}
function addChaptersToM4A {
	for file
	do
		MP4Box -chap "${file/.m4a/.chapters}" -add "$file" -new OUTPUT.m4a
		\mv -v OUTPUT.m4a OUTPUT.m4b
	done
	sync
}
function addChaptersToMP4 {
	for file
	do
		MP4Box -chap "${file/.mp4/.chapters}" -add "$file" -new OUTPUT.mp4
	done
	sync
}
function addSubtitles2media {
	local inputVideo=$1
	test $# -le 1 && {
		echo "=> Usage: $FUNCNAME inputVideo subFile1 subFile2 subFile3 ..." >&2
		return 1
	}

	local extension=${inputVideo/*./}

	case $extension in
		mp4|m4a|m4b|mov) subTitleCodec=mov_text;;
#		webm|mkv|mka) subTitleCodec=srt;;
		webm|mkv|mka) subTitleCodec=webvtt;;
		*) subTitleCodec=not_supported;;
	esac

	local outputVideo=${inputVideo/.$extension/_NEW.$extension}
	shift
	local numberOfSubtitles=$#
	(printf "ffmpeg -hide_banner -i $inputVideo ";printf -- "-i %s " "$@";printf -- "-map 0:a? -map 0:v? ";printf -- "-map %d " $(seq $numberOfSubtitles);printf -- "-c copy -c:s $subTitleCodec $outputVideo\n") | sh -x
	local retCode=$?
	sync
	sleep 1
	touch -r "$inputVideo" "$outputVideo"
	[ $retCode = 0 ] && echo && \mv -vf "$outputVideo" "$inputVideo" && \rm "$@"
}
function addRespectiveThumbnails4mp4Files {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME mp4File1 mp4File2 mp4File3 ..." >&2
		return 1
	}

	local timestampFileRef=null baseName=null artworkFile=null
	for mp4File
	do
		baseName="${mp4File/.*/}"
		artworkFile="$(\ls -1 "$baseName".* | \grep -v ".$extension$")"

		test ! -s "$artworkFile" && echo "=> [$FUNCNAME][WARNING] There is no artwork for <$mp4File>, skipping ..." >&2 && continue

		timestampFileRef=$(mktemp) && touch -r "$mp4File" $timestampFileRef
		addThumbnail2mp4_AtomicParsley "$artworkFile" "$mp4File" && rm "$artworkFile"
		touch -r $timestampFileRef "$mp4File" && \rm $timestampFileRef
	done
}
function addThumbnail2mp4_ffmpeg {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME artworkFile videoFileName" >&2
		return 1
	}

	local artworkFile="$1"
	shift

	local videoFileName="$1"
	local timestampFileRef=$(mktemp) && touch -r "$videoFileName" $timestampFileRef
	local extension=${videoFileName/*./}

	local ffprobeJSON_Info=$($ffprobe -hide_banner -v error -show_format -show_streams -print_format json "$videoFileName")
	local embeddedArtworkCodecName=$(echo $ffprobeJSON_Info | jq -r '[ .streams[] | select(.codec_type=="video") ][-1].codec_name')
	local major_brand=$(echo $ffprobeJSON_Info | jq -r '.format.tags.major_brand')
	local disposition_stream_specifier=null
	[ $major_brand = M4A ] && disposition_stream_specifier=v:0 || disposition_stream_specifier=v:1

	echo "[ffmpeg] Adding thumbnail to '$videoFileName'"
	$ffmpeg -loglevel repeat+error -i "$videoFileName" -i "$artworkFile" -map 0 -map 1 -c copy -disposition:$disposition_stream_specifier attached_pic "${videoFileName/.$extension/_NEW.$extension}"
	[ $? = 0 ] && set +x && mv -f "${videoFileName/.$extension/_NEW.$extension}" "$videoFileName" || set +x

	touch -r $timestampFileRef "$videoFileName" && \rm $timestampFileRef
	sync
}
function addThumbnail2mp4_mp4art {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME artworkFile videoFile" >&2
		return 1
	}

	local artworkFile="$1"
	shift

	local videoFileName="$1"
	local timestampFileRef=$(mktemp) && touch -r "$videoFileName" $timestampFileRef
	chmod u+w "$videoFileName"
	mp4art --remove "$videoFileName"
	mp4art --overwrite --add "$artworkFile" "$videoFileName"
	touch -r $timestampFileRef "$videoFileName" && \rm $timestampFileRef
	chmod -w "$videoFileName"
	sync
}
function addThumbnail2mp4_AtomicParsley {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME artworkFile videoFile" >&2
		return 1
	}

	local artworkFile="$1"
	local artworkExtension="${artworkFile/*./}"
	shift

	if ! file -b "$artworkFile" | \grep -q JPEG.*JFIF; then
		convert -verbose "$artworkFile" "${artworkFile/.*}_NEW.$artworkExtension" && mv -f "${artworkFile/.*}_NEW.$artworkExtension" "$artworkFile"
	fi

	local videoFileName="$1"
	local timestampFileRef=$(mktemp) && touch -r "$videoFileName" $timestampFileRef
	chmod u+w "$videoFileName"
	AtomicParsley "$videoFileName" --artwork "$artworkFile" --overWrite
	touch -r $timestampFileRef "$videoFileName" && \rm $timestampFileRef
	chmod -w "$videoFileName"
	sync
}
function addURL2mp4_m4a {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME url fileName" >&2
		return 1
	}

	local url="$1"
	local fileName="$2"
	local extension="${fileName/*./}"
	chmod u+w "$fileName"
	timestampFileRef=$(mktemp) && touch -r "$fileName" $timestampFileRef
	[ $extension = mp4 ] || [ $extension = m4a ] && mp4tags -m "$url" "$fileName" && touch -r $timestampFileRef "$fileName" && \rm $timestampFileRef
	chmod -w "$fileName"
	sync
}
function addURL2Audio_Video {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME url fileName" >&2
		return 1
	}

	local url="$1"
	local fileName="$2"
	local extension="${fileName/*./}"
	if $ffmpeg -i "$fileName" -map 0 -c copy -metadata description="$url" "${fileName%.*}-NEW.$extension";then
		touch -r "$fileName" "${fileName%.*}-NEW.$extension"
		mv -vf "${fileName%.*}-NEW.$extension" "$fileName"
	fi
	chmod -w "$fileName"
	sync
}
function any216kHzopus {
#	local inputFile="$1"
	local outputFile=""
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | sox -V -t wav - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2_3gp_amr_nb {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME [-b bitrate in kbps|12.2k] audioFile" >&2
		return 1
	}

	local bitrate=12.2k
	local sampling=8k
	local reSamplingOption=""
	local outputFile=""
	echo $1 | \grep -q -- "^-b" && bitrate=$2  && shift 2
	echo $1 | \grep -q -- "^-s" && sampling=$2 && shift 2
	bitrate=${bitrate/bps/}
	test -n "$sampling" && sampling=${sampling/k/} && sampling=${sampling/Hz/}

	for inputFile in "$@"
	do
		if [ -s "$inputFile" ]; then
			test -n "$sampling" && outputFile="${inputFile%.*}-${bitrate}bps-${sampling}kHz_amr_nb.3gp" || outputFile="${inputFile%.*}-${bitrate}bps_amr_nb.3gp"
			if [ ! -s "$outputFile" ]; then
				test -n "$sampling" && { sampling=$(perl -e "{print $sampling*1000}"); reSamplingOption="-ar:a $sampling"; }
set -x
				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a -map 0:s? $reSamplingOption -c:s mov_text -c:a amr_nb -b:a $bitrate -ac:a 1 "$outputFile"
set +x
				sync
				touch -r "$inputFile" "$outputFile"
				echo "=> outputFile = <$outputFile>"
			else
				echo "=> ERROR: The file <$outputFile> already exits." 1>&2
				continue
			fi
		else
			echo "=> ERROR: The file <$inputFile> does not exit or is empty." 1>&2
		fi
	done
}
function any2_3gp_amr_wb {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME [-b bitrate in kbps|23.85k] audioFile" >&2
		return 1
	}

	local bitrate=23.85k
	local sampling=16k
	local reSamplingOption=""
	local outputFile=""
	echo $1 | \grep -q -- "^-b" && bitrate=$2  && shift 2
	echo $1 | \grep -q -- "^-s" && sampling=$2 && shift 2
	bitrate=${bitrate/bps/}
	test -n "$sampling" && sampling=${sampling/k/} && sampling=${sampling/Hz/}

	for inputFile in "$@"
	do
		if [ -s "$inputFile" ]; then
			test -n "$sampling" && outputFile="${inputFile%.*}-${bitrate}bps-${sampling}kHz_amr_wb.3gp" || outputFile="${inputFile%.*}-${bitrate}bps_amr_wb.3gp"
			if [ ! -s "$outputFile" ]; then
				test -n "$sampling" && { sampling=$(perl -e "{print $sampling*1000}"); reSamplingOption="-ar:a $sampling"; }
set -x
				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a -map 0:s? $reSamplingOption -c:s mov_text -c:a amr_wb -b:a $bitrate -ac:a 1 "$outputFile"
set +x
				sync
				touch -r "$inputFile" "$outputFile"
				echo "=> outputFile = <$outputFile>"
			else
				echo "=> ERROR: The file <$outputFile> already exits." 1>&2
				continue
			fi
		else
			echo "=> ERROR: The file <$inputFile> does not exit or is empty." 1>&2
		fi
	done
}
function any2aac {
#	local inputFile="$1"
	local outputFile=""
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.aac"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -acodec aac -aprofile aac_low -q:a 1 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2aac_HE_AAC_VBR {
#	local inputFile="$1"
	local outputFile=""
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}_HE-AAC.aac"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he -vbr 1 "$outputFile"
			else
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he_v2 -vbr 1 "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2m4a {
#	local inputFile="$1"
	local outputFile=""
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.m4a"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -acodec aac -aprofile aac_low -q:a 1 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2m4a_HE_AAC_VBR {
#	local inputFile="$1"
	local outputFile=""
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}_HE-AAC.m4a"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he -vbr 1 "$outputFile"
			else
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he_v2 -vbr 1 "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2amr_nb {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME [-b bitrate in kbps|12.2k] audioFile" >&2
		return 1
	}

	local bitrate=12.2k
	local sampling=8k
	local reSamplingOption=""
	local outputFile=""
	echo $1 | \grep -q -- "^-b" && bitrate=$2  && shift 2
	echo $1 | \grep -q -- "^-s" && sampling=$2 && shift 2
	bitrate=${bitrate/bps/}
	test -n "$sampling" && sampling=${sampling/k/} && sampling=${sampling/Hz/}

	for inputFile in "$@"
	do
		if [ -s "$inputFile" ]; then
			test -n "$sampling" && outputFile="${inputFile%.*}-${bitrate}bps-${sampling}kHz_amr_nb.amr" || outputFile="${inputFile%.*}-${bitrate}bps_amr_nb.amr"
			if [ ! -s "$outputFile" ]; then
				test -n "$sampling" && { sampling=$(perl -e "{print $sampling*1000}"); reSamplingOption="-ar:a $sampling"; }
#				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a -map 0:s? $reSamplingOption -c:s mov_text -c:a amr_nb -b:a $bitrate -ac:a 1 "$outputFile" # removed subtitles because the resulting file produces many "[ffmpeg/audio] amrnb: Corrupt bitstream" errors
set -x
				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a $reSamplingOption -c:a amr_nb -b:a $bitrate -ac:a 1 "$outputFile"
set +x
				sync
				touch -r "$inputFile" "$outputFile"
				echo "=> outputFile = <$outputFile>"
			else
				echo "=> ERROR: The file <$outputFile> already exits." 1>&2
				continue
			fi
		else
			echo "=> ERROR: The file <$inputFile> does not exit or is empty." 1>&2
		fi
	done
}
function any2amr_wb {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME [-b bitrate in kbps|23.85k] audioFile" >&2
		return 1
	}

	local bitrate=23.85k
	local sampling=16k
	local reSamplingOption=""
	local outputFile=""
	echo $1 | \grep -q -- "^-b" && bitrate=$2  && shift 2
	echo $1 | \grep -q -- "^-s" && sampling=$2 && shift 2
	bitrate=${bitrate/bps/}
	test -n "$sampling" && sampling=${sampling/k/} && sampling=${sampling/Hz/}

	for inputFile in "$@"
	do
		if [ -s "$inputFile" ]; then
			test -n "$sampling" && outputFile="${inputFile%.*}-${bitrate}bps-${sampling}kHz_amr_wb.amr" || outputFile="${inputFile%.*}-${bitrate}bps_amr_wb.amr"
			if [ ! -s "$outputFile" ]; then
				test -n "$sampling" && { sampling=$(perl -e "{print $sampling*1000}"); reSamplingOption="-ar:a $sampling"; }
#				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a -map 0:s? $reSamplingOption -c:s mov_text -c:a amr_wb -b:a $bitrate -ac:a 1 "$outputFile" # removed subtitles because the resulting file produces many "[ffmpeg/audio] amrwb: Encountered a bad or corrupted frame" errors
set -x
				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a $reSamplingOption -c:a amr_wb -b:a $bitrate -ac:a 1 "$outputFile"
set +x
				sync
				touch -r "$inputFile" "$outputFile"
				echo "=> outputFile = <$outputFile>"
			else
				echo "=> ERROR: The file <$outputFile> already exits." 1>&2
				continue
			fi
		else
			echo "=> ERROR: The file <$inputFile> does not exit or is empty." 1>&2
		fi
	done
}
function any2opus {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME [-b bitrate in kbps|64k] [-s frequency in kHz|same as input by default] audioFile" >&2
		return 1
	}

	local bitrate=64k
	local sampling=""
	local reSamplingOption=""
	local outputFile=""
	echo $1 | \grep -q -- "^-b" && bitrate=$2  && shift 2
	echo $1 | \grep -q -- "^-s" && sampling=$2 && shift 2
	bitrate=${bitrate/bps/}
	test -n "$sampling" && sampling=${sampling/k/} && sampling=${sampling/Hz/}

	for inputFile in "$@"
	do
		if [ -s "$inputFile" ]; then
			test -n "$sampling" && outputFile="${inputFile%.*}-${bitrate}bps-${sampling}kHz_opus.oga" || outputFile="${inputFile%.*}-${bitrate}bps_opus.oga"
			if [ ! -s "$outputFile" ]; then
				test -n "$sampling" && { sampling=$(perl -e "{print $sampling*1000}"); reSamplingOption="-ar:a $sampling"; }
set -x
				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a $reSamplingOption -vn -c:a libopus -b:a $bitrate -vbr 1 "$outputFile"
set +x
				sync
				touch -r "$inputFile" "$outputFile"
				echo "=> outputFile = <$outputFile>"
			else
				echo "=> ERROR: The file <$outputFile> already exits." 1>&2
				continue
			fi
		else
			echo "=> ERROR: The file <$inputFile> does not exit or is empty." 1>&2
		fi
	done
}
function any2opusVBR {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME [-b bitrate in kbps|64k] [-s frequency in kHz|same as input by default] audioFile" >&2
		return 1
	}

	local bitrate=64k
	local sampling=""
	local reSamplingOption=""
	local outputFile=""
	echo $1 | \grep -q -- "^-b" && bitrate=$2  && shift 2
	echo $1 | \grep -q -- "^-s" && sampling=$2 && shift 2
	bitrate=${bitrate/bps/}
	test -n "$sampling" && sampling=${sampling/k/} && sampling=${sampling/Hz/}

	for inputFile in "$@"
	do
		if [ -s "$inputFile" ]; then
			test -n "$sampling" && outputFile="${inputFile%.*}-${bitrate}bps-${sampling}kHz_opus-VBR.oga" || outputFile="${inputFile%.*}-${bitrate}bps_opus-VBR.oga"
			if [ ! -s "$outputFile" ]; then
				test -n "$sampling" && { sampling=$(perl -e "{print $sampling*1000}"); reSamplingOption="-ar:a $sampling"; }
set -x
				time $ffmpeg $ffmpegOptions -i "$inputFile" -map 0:a $reSamplingOption -vn -sn -f wav - | opusenc - --vbr --bitrate $bitrate "$outputFile"
set +x
				sync
				touch -r "$inputFile" "$outputFile"
				echo "=> outputFile = <$outputFile>"
			else
				echo "=> ERROR: The file <$outputFile> already exits." 1>&2
				continue
			fi
		else
			echo "=> ERROR: The file <$inputFile> does not exit or is empty." 1>&2
		fi
	done
}
function any2wav {
#	local inputFile="$1"
	local outputFile=""
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.wav"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2wavSTDOUT {
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>" >&2
		time $ffmpeg -i "$inputFile" -vn -sn -f wav -
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function audio2Video4YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME aacFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	local audioCodec=$(audioCodecOfFile "$audio" 2>/dev/null)
	local video4YouTubeFile=""
	case $audioCodec in
	aac)video4YouTubeFile="${audio%.*}__4YouTube.mp4"
		time $ffmpeg -i "$audio" -loop 1 -framerate 4 -i "$picture" -shortest -speed max -map 0:a -c:a copy -map 1:v -preset medium -tune stillimage -crf 18 -pix_fmt yuv420p -movflags +frag_keyframe "$video4YouTubeFile" #cf. https://trac.ffmpeg.org/wiki/Encode/YouTube
		;;
	opus|vorbis)video4YouTubeFile="${audio%.*}__4YouTube.webm"
		time $ffmpeg -i "$audio" -loop 1 -framerate 1 -i "$picture" -shortest -speed max -map 0:a -c:a copy -map 1:v "$video4YouTubeFile"
		;;
	*) echo "=> ERROR : $FUNCNAME : $audioCodec is not supported yet." >&2;return 1 ;;
	esac
	sync
	videoInfo "$video4YouTubeFile"
}
function audio2stout {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		$ffmpeg -i "$inputFile" -f wav -
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function audioChannelLayoutOfFile {
	local audioChannelLayout
	local ffprobeJSON_File_Info=null
	for file
	do
#		audioChannelLayout=$($ffprobe "$file" -select_streams a:0? -show_entries stream=channel_layout -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		audioChannelLayout=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="audio") ][-1].channel_layout')
		printf "=> $file : audioChannelLayout = " >&2
		echo $audioChannelLayout
	done
}
function audioCodecOfFile {
	local audioCodec
	local ffprobeJSON_File_Info=null
	for file
	do
#		audioCodec=$($ffprobe "$file" -select_streams a:0? -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		audioCodec=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="audio") ][-1].codec_name')
		printf "=> $file : audioCodec = " >&2
		echo $audioCodec
	done
}
function audioDelay {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME video delay" >&2
		return 1
	}

	local video=$1
	local delay=$2
	local extension=${video/*./}
	time $ffmpeg -i "$video" -itsoffset $delay -i "$video" -c copy -map 0:v -map 1:a "${video%.*}-FIXED.$extension" #cf. https://superuser.com/questions/982342/in-ffmpeg-how-to-delay-only-the-audio-of-a-mp4-video-without-converting-the-au/983153#983153
}
function audioShift {
	if [ $# != 2 ] && [ $# != 3 ]; then
		echo "=> Usage: $FUNCNAME <filename> hh:mm:ss[.xxx]"
		return 1
	fi

	fileName="$1"
	extension=${fileName/*./}
	fileBaseName=${fileName%.???}
	shift=$2
	time $ffmpeg -itsoffset $shift -i "$fileName" $remuxOptions "$fileBaseName-SHIFTED.$extension"
	sync
	touch -r "$fileName" "$fileBaseName-SHIFTED.$extension"
}
function avprobe {
	for arg
	do
		echo "$arg" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $avprobe $avprobeOptions "$(youtube-dl -gf best -- "$arg")" || command avprobe $avprobeOptions -probesize 400M -analyzeduration 400M "$arg"
#	done 2>&1 | cut -c 1-$(tput cols)
	done
}
function containerOfFile {
	local container
	local ffprobeJSON_File_Info=null
	for file
	do
#		container=$($ffprobe "$file" -show_entries format=format_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		container=$(echo $ffprobeJSON_File_Info | jq -r .format.format_name | cut -d, -f1)
		printf "=> $file : container = " >&2
		echo $container
	done
}
function cropdetect {
	ffmpeg -i "$1" -t 1 -vf cropdetect -f null - 2>&1 | awk '/crop/{line=$NF}END{print line}'
}
function ffplay {
	local args=("$@")
	local lastArg="${@: -1}"
	type -P ffprobe >/dev/null && {
		echo "$lastArg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffplay -user_agent "$userAgent" $ffplayOptions "$(youtube-dl -gf best -- "${args[@]}")" || $ffplay $ffplayOptions "${args[@]}"
		echo
	}
}
function ffprobe {
	type -P ffprobe >/dev/null && {
		for arg
		do
			echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions -user_agent "$userAgent" "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
			echo
		done 2>&1
	}
}
function ffprobe2Flat {
	local ffprobeOptions="-v error -show_format -show_streams -of flat"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function ffprobe2Ini {
	local ffprobeOptions="-v error -show_format -show_streams -of ini"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function ffprobe2JSON {
	local ffprobeUserAgentOption="-user_agent \"$userAgent\""
	local ffprobeOptions="-v error -show_format -show_streams -of json"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeUserAgentOption $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function ffprobe2XML {
	local ffprobeOptions="-v error -show_format -show_streams -of xml"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function flac2spx {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.flac/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
#			time sox -V "$inputFile" -r 16k $namedPipe norm &
#			time sox -V "$inputFile" $namedPipe rate 16k norm &
			time $ffmpeg -i "$inputFile" -ar 16k $namedPipe -y &
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr $namedPipe "$outputFile"
			time speexenc -V --quality 10 --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function frameCount {
	for video
	do
		echo "Video : $video"
		printf "Frames : "
		mediainfo --Inform="Video;%FrameCount%" "$video"
		echo
	done
}
function m2ts2mp4 {
	local inputFile="$1"
	if [ $# != 2 ]
	then
		echo "=> Usage: $FUNCNAME inputFileName outputFileName [ffmpegCLIParameters]" >&2
		return 1
	fi

	shift
	outputFile="$1"
	outputExtension=${outputFile/*./}
	local options
	case $outputExtension in
		vob) options="-f mpeg" ;;
		*) options="" ;;
	esac

	time $ffmpeg -i "$inputFile" -map 0 -c:v copy -c:a copy -c:s mov_text $options "$@"
	sync
	touch -r "$inputFile" "$outputFile"
}
function m3uConcat {
	files="$@"
	echo "#EXTM3U"
	egrep -hv "EXTM3U|^# *$" $files | dos2unix | egrep -v "^$"
}
function m4a2aac {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -acodec copy $@ "${file/.m4a/.aac}"
	for file
	do
		time $ffmpeg -i "$file" -acodec copy "${file/.m4a/.aac}"
		touch -r "$file" "${file/.m4a/.aac}"
		sync
	done
}
function mediainfoSummary {
	for media
	do
		mediainfo "$media"
		echo
	done | \egrep "^($|Complete name|Width|Height|Encoding settings|Format  |Format version|Format profile|Duration|Video|Audio|Text|Menu|Language)| size|Kbps|[Bb]it ?rate|Frame rate|Sampling rate|Channel|Cover|Info"
}
function mkv2ogg {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -vn -acodec copy $@ "${file/.mkv/.ogg}"
	for file
	do
		time $ffmpeg -i "$file" -vn -acodec copy "${file/.mkv/.ogg}"
		touch -r "$file" "${file/.mkv/.ogg}"
		sync
	done
}
function mkvInfo {
#	file="$1"
#	shift
#	time time mkvinfo -s "$file" | grep Track
	for file
	do
		echo "=> file = $file" >&2
		echo >&2
		time mkvinfo -s "$file"
		echo >&2
	done | grep Track
}
function moov_atomFix {
	for inputFile
	do
		echo "=> inputFile = <$inputFile>" >&2
		outputFile="${inputFile/.mp4/_moov_atom_FIXED.mp4}"
		qtfaststart "$inputFile" "$outputFile" && touch -r "$inputFile" "$outputFile" && echo "=> outputFile = <$outputFile>" >&2
		sync
	done
}
function mp32opus {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" $@ "${file%.*}.opus"
	for file
	do
set -x
		time $ffmpeg $ffmpegOptions -i "$file" -map 0:a -map 0:v:0? -c:a libopus -c:v libtheora -q:v 10 -r:v 1 "${file%.*}.ogg"
set +x
		touch -r "$file" "${file%.*}.ogg"
		sync
	done
}
function mp32spx {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		title=$(mp3info2 -p %t "$inputFile")
		echo "==> title = <$title>"
		album=$(mp3info -p %l "$inputFile")
		echo "==> album = <$album>"
#		artist=$(mp3info -p %a "$inputFile")

		outputFile=${inputFile/.mp3/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time sox -V "$inputFile" -t wav - channels 1 rate 16k norm | speexenc --title "$title" --comment ALBUM="$album" -V --vbr --quality 10 - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp42mp4_HE_AAC_CBR {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile=${inputFile/.mp4/_HE-AAC.mp4}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" $remuxOptions -acodec libfdk_aac -aprofile aac_he    -ab 64k $mp4Options "$outputFile"
			else
				time $ffmpeg -i "$inputFile" $remuxOptions -acodec libfdk_aac -aprofile aac_he_v2 -ab 64k $mp4Options "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function mp4DashAudio2aac {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.mp4/.aac}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp4DashAudio2m4a {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.mp4/.m4a}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp4Info {
	for file
	do
		echo "=> file = <$file>"
		AtomicParsley "$file" -T 1 | sed '/Movie duration/,$!d'
	done
}
function mp4Repair {
	for file
	do
		extension=mp4
		time $ffmpeg -i "$file" $remuxOptions $mp4Options "${file/.$extension/_REPAIRED.$extension}"
		sync
		touch -r "$file" "${file/.$extension/_REPAIRED.$extension}"
	done
}
function opus2WebM4YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME opusFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	time $ffmpeg -i "$audio" -loop 1 -framerate 1 -i "$picture" -shortest -speed max -c:a copy "${audio%.*}.webm"
	sync
}
function opus2opus {
	set +x
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME [-b 64k] [-s 48k] opusFile" >&2
		return 1
	}

	local bitrate=64k
	local sampling=48k
	echo $1 | \grep -q -- "^-b" && bitrate=$2  && shift 2
	echo $1 | \grep -q -- "^-s" && sampling=$2 && shift 2
	sampling=${sampling/k/}

	for inputFile in "$@"
	do
		if [ -s "$inputFile" ]; then
			echo "=> inputFile = <$inputFile>"
			outputFile="${inputFile%.*}-${bitrate}bps-${sampling}kHz.opus"
			echo "==> outputFile = $outputFile"
			if [ ! -s "$outputFile" ]; then
				sampling=$(perl -e "{print $sampling*1000}")
#				time $ffmpeg $ffmpegOptions -i "$inputFile" -ar $sampling -vn -sn -f wav - | opusenc - --bitrate $bitrate "$outputFile"
set -x
				time opusdec --force-wav --rate $sampling "$inputFile" - | opusenc - --bitrate $bitrate "$outputFile"
set +x
				sync
				touch -r "$inputFile" "$outputFile"
				echo "=> outputFile = <$outputFile>"
			else
				echo "=> ERROR: The file <$outputFile> already exits." 1>&2
				continue
			fi
		else
			echo "=> ERROR: The file <$inputFile> does not exit or is empty." 1>&2
		fi
	done
}
function replaceAudioOfVideoFile {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME videoFile audioFile" >&2
		return 1
	}

	local videoFile="$1"
	local audioFile="$2"
	local extension="${videoFile/*./}"
	time $ffmpeg -i "$videoFile" -i "$audioFile" -map 0:v:0 -map 1:a:0 -c copy -shortest "${videoFile/.*/}_NEW.$extension"
	sync
}
function sizeOfStream {
	local size
	local totalExpr="0"
	local format=18

	if [ $# = 0 ];then
		echo "=> $FUNCNAME [format] url1 url2 ..." >&2
		return 1
	fi

	trap 'rc=130;set +x;echo "=> $FUNCNAME: CTRL+C Interruption trapped.">&2;return $rc' INT

	echo $1 | \grep -q ^http || {
		format=$1
		shift
	}

	for url
	do
		size=$(curl -sI "$(youtube-dl -gf $format -- "$url")" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1}/Content-Length:/{print$2/2^20}')
		totalExpr="$totalExpr+$size"
		echo "$url $size Mo"
	done
	total=$(perl -e "printf $totalExpr")
	echo "=> total = $total Mo"

	trap - INT
}
function spx216kHzopus {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if [ $(audioChannelLayoutOfFile "$inputFile" 2>/dev/null) = stereo ]
			then
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 2 - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			else
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 1 - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			fi
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function spx216kHzspx {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.oga/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q stereo
			then
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 2 - -t wav - channels 1 rate 16k norm | speexenc -V --quality 10 --vbr - "$outputFile"
			else
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 1 - -t wav - channels 1 rate 16k norm | speexenc -V --quality 10 --vbr - "$outputFile"
			fi
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function spx2opus {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			#freq=$(mediainfo --Inform="Audio;%SamplingRate%" "$inputFile")
			time audio2stout "$inputFile" | opusenc - "$outputFile"
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function to16_9 {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -aspect 16/9 $remuxOptions "${video/.$extension/_16_9eme.$extension}"
	done
}
function urlOfVideo {
	local format_name=unknown
	local protocolRegExp="(https?|ftps?|s?ftp)://"
	for video
	do
		format_name="$(videoFormat $video)"
		case $format_name in
			mov,mp4,m4a,3gp,3g2,mj2) tag=description;;
			matroska,webm) tag=purl;;
		*) echo "=> The $format_name is not supported yet." >&2 && continue;;
		esac
		[ $# -gt 1 ] && printf "=> video = $video\t url = "
		url=$($ffprobe -v error -show_entries format_tags=$tag -of default=noprint_wrappers=1:nokey=1 "$video" | egrep "$protocolRegExp")
		echo $url
	done
}
function urlinfo {
	for url
	do
		echo "=> url = $url"
		time $ffprobe -user_agent "$userAgent" $(time youtube-dl -gf best -- "$url")
	done
}
function subtitleCodecOfFile {
	local subtitleCodec
	local ffprobeJSON_File_Info=null
	for file
	do
#		subtitleCodec=$($ffprobe "$file" -select_streams s:0? -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		subtitleCodec=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="subtitle") ][-1].codec_name')
		printf "=> $file : subtitleCodec = " >&2
		echo $subtitleCodec
	done
}
function videoCodecOfFile {
	local videoCodec
	local ffprobeJSON_File_Info=null
	for file
	do
#		videoCodec=$($ffprobe "$file" -select_streams v:0? -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		videoCodec=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="video") ][-1].codec_name')
		printf "=> $file : videoCodec = " >&2
		echo $videoCodec
	done
}
function videoConcatFFMPEG_Losslessly-concat_demuxer {
	if [ $# -lt 3 ]
	then
		echo "=> Usage: $FUNCNAME destFile video1 video2 ..." >&2
		return 1
	fi

	local destFile="$1"
	shift
	local videosListFile="$(mktemp -p .)"
	local indexOfFiles=-1
	for video
	do
		extension="${video/*./}"
		echo "file '$video'" >> "$videosListFile"
		let indexOfFiles+=1
	done

set -x
	time $ffmpeg -f concat -i "$videosListFile" -c copy $(printf -- "-map %d " {1..$indexOfFiles}) "$destFile"
set +x
	rm -vf "$videosListFile"
	sync
}
function videoConcatFFMPEG_WithLoss-concat_demuxer {
	if [ $# -lt 3 ]
	then
		echo "=> Usage: $FUNCNAME destFile video1 video2 ..." >&2
		return 1
	fi

	local destFile="$1"
	local extension="${destFile/*./}"
	shift
	local videosListFile="$(mktemp -p .)"
	local indexOfFiles=-1
	[ $extension = mp4 ] && local mp4Options="-movflags +frag_keyframe"
	for video
	do
		echo "file '$video'" >> "$videosListFile"
		let indexOfFiles+=1
	done

set -x
	time $ffmpeg -f concat -i "$videosListFile" $(printf -- "-map %d " {1..$indexOfFiles}) $mp4Options "$destFile"
set +x
	rm -vf "$videosListFile"
	sync
}
function videoConcatFFMPEG_WithLoss-concat_filter {
	if [ $# -lt 3 ]
	then
		echo "=> Usage: $FUNCNAME destFile video1 video2 ..." >&2
		return 1
	fi

	local destFile="$1"
	local extension="${destFile/*./}"
	shift
	local indexOfFiles=0
	[ $extension = mp4 ] && local mp4Options="-movflags +frag_keyframe"
	local filter_complex=""
	for video
	do
		filter_complex+="[$indexOfFiles:v] [$indexOfFiles:a] "
		let indexOfFiles+=1
	done
	filter_complex+="concat=n=$indexOfFiles:v=1:a=1 [v] [a]"

set -x
	time $ffmpeg $(printf -- "-i %s " "$@") -filter_complex "$filter_complex" -map "[v]" -map "[a]" $mp4Options "$destFile"
set +x
	sync
}
function videoDelay {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME video delay" >&2
		return 1
	}

	local video=$1
	local delay=$2
	local extension=${video/*./}
	time $ffmpeg -i "$video" -itsoffset $delay -i "$video" -c copy -map 1:v -map 0:a "${video%.*}-FIXED.$extension" #cf. https://superuser.com/questions/982342/in-ffmpeg-how-to-delay-only-the-audio-of-a-mp4-video-without-converting-the-au/983153#983153
}
function videoDVDInfo {
	cdr_device=/dev/dvd
	longestTrack=$(\lsdvd -Oy | awk -F ':|,| ' '/longest_track/{print$(NF-1)}')
	tccat -i $cdr_device -T $longestTrack,-1 2>/dev/null | $ffprobe - 2>&1
}
function videoFormat {
	local format_name=unknown
	for video
	do
		$ffprobe -v error -of default=noprint_wrappers=1:nokey=1 -show_entries format=format_name "$video"
	done
}
function videoGet {
	ls "$@" >/dev/null || return
	for file
	do
		extension=${file/*./}
		videoFormat=$(ffprobe "$file" 2>&1 | grep -v Video:.mjpeg | awk '/Video/{print$4}' | sed "s/,$//")
		outputExtension=${videoExtension[$videoFormat]}
		outputFileName=${file/.$extension/_VIDEO.$outputExtension}
		outputFileName=$(echo $outputFileName | cut -d/ -f3-) # Remove the two leading directories from the path
		minimumVideoStreamSize=$(mediainfo --Output="Video;%StreamSize%" "$file") || return
		if test -s "$outputFileName" && [ $(stat -c '%s' "$outputFileName") -ge $minimumVideoStreamSize ]
		then
			echo "=> INFO: The file $file has already been converted to $outputFileName." >&2
			continue
		fi
		\mkdir -pv $(dirname $outputFileName)
		time $ffmpeg -i "$file" -an -codec copy $options "$outputFileName" -y
		touch -r "$file" "$outputFileName"
		sync
		echo
		test -s "$outputFileName" && echo "=> Output file is: <$outputFileName>."
	done
}
function videoInfo {
	local columns=$COLUMNS
#	local columns="" # To see more info than the width of the screen
	local size=0
	type -P ffprobe >/dev/null && {
		local youtube_dl='command youtube-dl'
		local ffprobe='command ffprobe -hide_banner'
		for urlOrFile
		do
			echo "=> urlOrFile = $urlOrFile"
			if echo "$urlOrFile" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://"
			then
				#remote stream
				streamMimeType=$(\curl -qLs --user-agent "$userAgent" "$urlOrFile" | file -bi -)
				if echo $streamMimeType | \grep "^text/" -q;then
					echo "=> This stream needs first to be resolved by youtube-dl ..."
					possibleFormats=best[ext=mp4]/best[ext=webm]/best[ext=flv]/18/webm/sd/http-480
					infos="$($youtube_dl -gef $possibleFormats -- "$urlOrFile")"
					test -z "$infos" && continue
					title="$(echo "$infos" | sed -n 1p )"
					directURLOfStream="$(echo "$infos" | sed -n 2p)"
					size=$(\curl -qLsI --user-agent "$userAgent" "$directURLOfStream" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Title: $title"
					echo "Size: $size"
					time $ffprobe -user_agent "$userAgent" $ffprobeOptions "$directURLOfStream" 2>&1
				elif echo $streamMimeType | \grep charset=binary -q;then
					#direct stream
					echo "=> This stream is direct stream"
					size=$(\curl -qLsI --user-agent "$userAgent" "$urlOrFile" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Size: $size"
					time $ffprobe -user_agent "$userAgent" "$urlOrFile"
				fi
			else
				#Local file
				[ ! -s "$urlOrFile" ] && echo "=> ERROR: The file <$urlOrFile> is empty or does not exist." 1>&2 && continue
				echo "=> This file is local to this machine."
				size=$(\ls -l "$urlOrFile" | awk '/[0-9]+/{printf "%8.3f MiB\n",$5/1024^2}')
				echo "Size: $size"
				$ffprobe "$urlOrFile" || $ffprobe $ffprobeOptions "$urlOrFile"
			fi
			echo
		done 2>&1 | \egrep -vi "^ +(:\s+$|comment|description +: [^/]+$)" | uniq | egrep --color -iw "^$|description.*:/|PURL.*:/|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Channel.*:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
	}
}
function videoInfoOLD {
	local columns=$(tput cols)
#	local columns="" # To see more info than the width of the screen
	local size=0
	type -P ffprobe >/dev/null && {
		for urlOrFile
		do
			echo "=> urlOrFile = $urlOrFile"
			if echo "$urlOrFile" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://"
			then
				#remote stream
				if \curl -s "$urlOrFile" | file -bi - | \grep -q "^text/"
				then
					echo "=> This stream needs first to be resolved by youtube-dl ..."
					possibleFormats=best[ext=mp4]/best[ext=webm]/best[ext=flv]/18/webm/sd/http-480
					infos="$(youtube-dl -gef $possibleFormats -- "$urlOrFile")"
					test -z "$infos" && continue
					title="$(echo "$infos" | sed -n 1p )"
					directURLOfStream="$(echo "$infos" | sed -n 2p)"
					size=$(\curl -sI "$directURLOfStream" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Title: $title"
					echo "Size: $size"
					command ffprobe $ffprobeOptions "$directURLOfStream" 2>&1
				else
					#direct stream
					echo "=> This stream is direct stream"
					size=$(\curl -sI "$urlOrFile" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Size: $size"
					$ffprobe "$urlOrFile"
				fi
			else
				echo "=> The file is local to this machine."
				#Local file
				size=$(\ls -l "$urlOrFile" | awk '/[0-9]+/{printf "%8.3f MiB\n",$5/1024^2}')
				echo "Size: $size"
				$ffprobe "$urlOrFile" || $ffprobe $ffprobeOptions "$urlOrFile"
			fi
			echo
#		done 2>&1 | cut -c 1-$columns | \egrep -iw "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not" | uniq | \egrep -iw --color "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
		done 2>&1 | \egrep -iw "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not" | uniq | \egrep -iw --color "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
	}
}
function videoRemoveMetaData {
	local extension videoBaseName outputVideo
	for video
	do
		extension="${video/*./}"
#		videoBaseName="${video%.???}"
		outputVideo="${video/.$extension/-NoMetaData.$extension}"
		echo "=> Processing = $video ..." >&2
		$ffmpeg -i "$video" -map 0:v:0? -map 0:a? -map 0:s? -c copy -map_metadata:g -1 "$outputVideo"
		test $? = 0 && {
			touch -r "$video" "$outputVideo"
			sync
			echo >&2
			$ffprobe "$outputVideo"
		}
	done
}
function videoRemoveMetaDataAndSubtitles {
	local extension videoBaseName outputVideo
	for video
	do
		extension="${video/*./}"
#		videoBaseName="${video%.???}"
		outputVideo="${video/.$extension/-NoMetaData.$extension}"
		echo "=> Processing = $video ..." >&2
		$ffmpeg -i "$video" -map 0:v:0? -map 0:a? -c copy -map_metadata:g -1 "$outputVideo"
		test $? = 0 && {
			touch -r "$video" "$outputVideo"
			sync
			echo >&2
			$ffprobe "$outputVideo"
		}
	done
}
function videoRemux {
	local inputFile="$1"
	if [ $# != 2 ]
	then
		echo "=> Usage: $FUNCNAME inputFileName outputFileName [ffmpegCLIParameters]" >&2
		return 1
	fi

	shift
	outputFile="$1"
	outputExtension=${outputFile/*./}
	local options
	case $outputExtension in
		vob) options="-f mpeg" ;;
		*) options="" ;;
	esac

	time $ffmpeg -i "$inputFile" $remuxOptions $options "$@"
	sync
	touch -r "$inputFile" "$outputFile"
}
function videoRepair {
	for video
	do
		extension="${video/*./}"
		time $ffmpeg -i "$video" $remuxOptions "${video/.$extension/-REPAIRED.$extension}"
		sync
		touch -r "$video" "${video/.$extension/-REPAIRED.$extension}"
	done
}
function videoRotateLeft {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -map 0 -c copy -metadata:s:v:0 rotate=90 "${video%.*}-ROTATED.$extension"
	done
}
function videoRotateRight {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -map 0 -c copy -metadata:s:v:0 rotate=-90 "${video%.*}-ROTATED.$extension"
	done
}
function videoSplit {
	if [ $# != 2 ] && [ $# != 3 ]
	then
		echo "=> Usage: $FUNCNAME <filename> hh:mm:ss[.xxx] [ hh:mm:ss[.xxx] ]" >&2
		return 1
	fi

	fileName="$1"
	test -r "$fileName" || {
		echo "=> ERROR: <$fileName> cannot be read by $USER or does not exist." >&2
		return 2
	}

	extension=${fileName/*./}
	fileBaseName=${fileName%.???}
	begin=$2
	outputFile="$fileBaseName-CUT.$extension"
	chmod -x "$fileName"

#	[ $extension = mp4 ] && remuxOptions="$remuxOptions $mp4Options"
	if test $# = 3
	then
		end=$3
#		duration=$(echo $(date +%s.%N -d $end) - $(date +%s.%N -d $begin) | bc -l)
#		time $ffmpeg -ss $begin -t $duration -i "$fileName" $remuxOptions "$outputFile"
		set -x
		time $ffmpeg -ss $begin -i "$fileName" -to $end $remuxOptions "$outputFile"
	else
		set -x
		time $ffmpeg -ss $begin -i "$fileName" $remuxOptions "$outputFile"
	fi
	set +x
	sync
	touch -r "$fileName" "$outputFile"
	echo "=> outputFile = <$outputFile>"
}
function videoURL {
	for video
	do
		printf "$video : "
		$ffprobe "$video" 2>&1 | awk '/PURL|description/{print$3;exit;}'
	done
}
function vlcRecord {
	local file=vlc-record-$(date +"%Y-%m-%d-%Hh%Mm%Ss")-$(echo $1 | tr "[:/]" "_" ).ts
	echo "=> The recording will be saved into the file: <$file>"
	cvlc --verbose=1 --ipv4-timeout=600  --logmode=text --log-verbose=-1 --logfile=vlcrecord_$(date +"%Y-%m-%d-%Hh%Mm%Ss").out --sout=file:$file $1
	echo "=> The recording is saved into the file: <$file>" >&2
}
function wav16k2spx {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile=${inputFile/.wav/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr "$inputFile" "$outputFile"
			time speexenc -V --quality 10 --vbr "$inputFile" "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav216kHz {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_16k.wav}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time sox -V "$inputFile" "$outputFile" rate 16k norm
			time $ffmpeg -i "$inputFile" -ar 16k "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav216kwav {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_16kHz.wav}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -ar 16k "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav2opus {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
			time sox -V "$inputFile" $namedPipe rate 16k norm &
#			time opusenc --title "$title" --album ALBUM="$album" --vbr $namedPipe "$outputFile"
			time opusenc --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav2spx {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
#			time sox -V "$inputFile" -r 16k $namedPipe norm &
			time sox -V "$inputFile" $namedPipe rate 16k norm &
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr $namedPipe "$outputFile"
			time speexenc -V --quality 10 --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function webcamInfo {
	local videoDevice=/dev/video0
	[ $# = 1 ] && videoDevice=$1

	if ls $videoDevice >/dev/null;then
		xawtv -hwscan 2>&1
		echo
		v4l2-ctl -D -d $videoDevice
		echo
		v4l2-ctl --list-formats-ext -d $videoDevice
		echo
		\ffmpeg -hide_banner -list_formats all -i $videoDevice 2>&1
	fi
}
function webmAudio2ogg {
	$local inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.webm/.ogg}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}

set +x
test "$debug" -gt 0 && echo "=> END of $bold${colors[blue]}$(basename ${BASH_SOURCE[0]})$normal"
