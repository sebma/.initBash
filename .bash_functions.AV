# vim: set ft=bash noet:
set +x
! declare 2>&1 | grep -wq ^colors= && [ $BASH_VERSINFO -ge 4 ] && source $initDir/.colors
test "$debug" -gt 0 && echo "=> Running $bold${colors[blue]}$(basename ${BASH_SOURCE[0]})$normal ..."

\which ffmpeg  >/dev/null 2>&1 && ffmpeg="command  ffmpeg  -hide_banner" &&  ffmpegOptions="-probesize 400M -analyzeduration 400M"
\which ffplay  >/dev/null 2>&1 && ffplay="command ffplay -hide_banner" && ffplayOptions=$ffmpegOptions
\which ffprobe >/dev/null 2>&1 && ffprobe="command ffprobe -hide_banner" && ffprobeOptions=$ffmpegOptions

#youtube_dl="eval LANG=C.UTF-8 command youtube-dl" # i.e https://unix.stackexchange.com/questions/505733/ # eval A EVITER

remuxOptions="-map 0 -c copy"
mp4Options="-movflags +frag_keyframe"
mp4RemuxOptions="-map 0 -c copy -c:s mov_text"
aac2m4aOptions="-bsf:a aac_adtstoasc"
cdr_device=/dev/dvd

[ $BASH_VERSINFO -ge 4 ] && declare -Ag audioExtension videoExtension audioDecode # i.e https://unix.stackexchange.com/a/535721/135038
audioExtension=( [libspeex]=spx [speex]=spx [opus]=opus [vorbis]=ogg [aac]=m4a [mp3]=mp3 [mp2]=mp2 [ac3]=ac3 [wmav2]=wma [pcm_dvd]=wav [pcm_s16le]=wav )
videoExtension=( [h264]=m4v [mpeg1video]=mpg [mpeg2video]=vob [mpeg4]=avi [flv1]=flv [wmv3]=wmv )
audioDecode=( [libspeex]=$(which speexdec 2>/dev/null) [speex]=$(which speexdec 2>/dev/null) [opus]=$(which opusdec 2>/dev/null) [vorbis]=$(which oggdec 2>/dev/null) )

#function aacDir2mp3 { inp=aac; shopt -s globstar && time for f in **/*.$inp; do time avconv -i "$f" "${f/.$inp/.mp3}" && rm -v "$f"; done; }
function _16kwav16k2opus {
	local inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time opusenc --title "$title" --album ALBUM="$album" --vbr "$inputFile" "$outputFile"
			time opusenc --vbr "$inputFile" "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function aac2MP44YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME aacFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	time $ffmpeg -i "$audio" -loop 1 -framerate 4 -i "$picture" -shortest -speed max -c:a copy -preset medium -tune stillimage -crf 18 -pix_fmt yuv420p -movflags +frag_keyframe "${audio%.*}.mp4" #cf. https://trac.ffmpeg.org/wiki/Encode/YouTube
}
function aac2m4a {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -acodec copy $aac2m4aOptions $@ "${file/.aac/.m4a}"
	for file
	do
		time $ffmpeg -i "$file" -acodec copy $aac2m4aOptions "${file/.aac/.m4a}"
		touch -r "$file" "${file/.aac/.m4a}"
		sync
	done
}
function aacDir2mp3 { shopt -s globstar && for f in **/*.aac; do /bin/mv -vi "$f" "${f/.aac/.m4a}"; done; time pacpl -v --eopts "-v" -r -k -t mp3 .; }
function audioGet {
#	ls "$@" >/dev/null || return
	for file
	do
		extension=${file/*./}
		audioCodec=$(audioCodecOfFile "$file" 2>/dev/null)
		outputExtension=${audioExtension[$audioCodec]}
		outputFileName=${file/.$extension/_AUDIO.$outputExtension}
		outputFileName=$(echo $outputFileName | cut -d/ -f3-) # Remove the two leading directories from the path
		minimumAudioStreamSize=$(mediainfo --Output="Audio;%StreamSize%" "$file") || return
		if test -s "$outputFileName" && [ $(stat -c '%s' "$outputFileName") -ge $minimumAudioStreamSize ]
		then
			echo "=> INFO: The file $file has already been converted to $outputFileName." >&2
			continue
		fi
		\mkdir -pv $(dirname $outputFileName)
		if [ $outputExtension = aac ];then
			time $ffmpeg -i "$file" -map 0 -map -0:v -codec copy "$outputFileName" -y
		else
			time $ffmpeg -i "$file" -map 0 -map -0:v:0 -codec copy "$outputFileName" -y
		fi
		touch -r "$file" "$outputFileName"
		sync
		echo
		test -s "$outputFileName" && echo "=> Output file is: <$outputFileName>."
	done
}
function addChaptersToM4A {
	for file
	do
		MP4Box -chap "${file/.m4a/.chapters}" -add "$file" -new OUTPUT.m4a
		\mv -v OUTPUT.m4a OUTPUT.m4b
	done
	sync
}
function addChaptersToMP4 {
	for file
	do
		MP4Box -chap "${file/.mp4/.chapters}" -add "$file" -new OUTPUT.mp4
	done
	sync
}
function addSubtitles2media {
	local inputVideo=$1
	test $# -le 1 && {
		echo "=> Usage: $FUNCNAME inputVideo subFile1 subFile2 subFile3 ..." >&2
		return 1
	}

	local extension=${inputVideo/*./}

	case $extension in
		mp4|m4a|m4b|mov) subTitleCodec=mov_text;;
#		webm|mkv|mka) subTitleCodec=srt;;
		webm|mkv|mka) subTitleCodec=webvtt;;
		*) subTitleCodec=not_supported;;
	esac

	local outputVideo=${inputVideo/.$extension/_NEW.$extension}
	shift
	local numberOfSubtitles=$#
	(printf "ffmpeg -hide_banner -i $inputVideo ";printf -- "-i %s " "$@";printf -- "-map 0:a? -map 0:v? ";printf -- "-map %d " $(seq $numberOfSubtitles);printf -- "-c copy -c:s $subTitleCodec $outputVideo\n") | sh -x
	local retCode=$?
	sync
	sleep 1
	touch -r "$inputVideo" "$outputVideo"
	[ $retCode = 0 ] && echo && \mv -vf "$outputVideo" "$inputVideo" && \rm "$@"
}
function addRespectiveThumbnail2mp4 {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME mp4File1 mp4File2 mp4File3 ..." >&2
		return 1
	}

	local timestampFileRef=null baseName=null artworkFile=null
	for mp4File
	do
		baseName="${mp4File/.*/}"
		artworkFile="$(\ls -1 "$baseName".* | \grep -v ".$extension$")"

		test ! -s "$artworkFile" && echo "=> [$FUNCNAME][WARNING] There is no artwork for <$mp4File>, skipping ..." >&2 && continue

		timestampFileRef=$(mktemp) && touch -r "$mp4File" $timestampFileRef
		addThumbnail2mp4_AtomicParsley "$artworkFile" "$mp4File" && rm "$artworkFile"
		touch -r $timestampFileRef "$mp4File" && \rm $timestampFileRef
	done
}
function addThumbnail2mp4_ffmpeg {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME artworkFile file" >&2
		return 1
	}

	local artworkFile="$1"
	shift

	local fileName="$1"
	local timestampFileRef=$(mktemp) && touch -r "$fileName" $timestampFileRef
	local extension=${fileName/*./}

	local ffprobeJSON_Info=$($ffprobe -hide_banner -v error -show_format -show_streams -print_format json "$fileName")
	local embeddedArtworkCodecName=$(echo $ffprobeJSON_Info | jq -r '[ .streams[] | select(.codec_type=="video") ][-1].codec_name')
	local major_brand=$(echo $ffprobeJSON_Info | jq -r '.format.tags.major_brand')
	local disposition_stream_specifier=null
	[ $major_brand = M4A ] && disposition_stream_specifier=v:0 || disposition_stream_specifier=v:1

	echo "[ffmpeg] Adding thumbnail to '$fileName'"
	$ffmpeg -loglevel repeat+error -i "$fileName" -i "$artworkFile" -map 0 -map 1 -c copy -disposition:$disposition_stream_specifier attached_pic "${fileName/.$extension/_NEW.$extension}"
	[ $? = 0 ] && set +x && mv -f "${fileName/.$extension/_NEW.$extension}" "$fileName" || set +x

	touch -r $timestampFileRef "$fileName" && \rm $timestampFileRef
	sync
}
function addThumbnail2mp4_mp4art {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME artworkFile file" >&2
		return 1
	}

	local artworkFile="$1"
	shift

	local fileName="$1"
	local timestampFileRef=$(mktemp) && touch -r "$fileName" $timestampFileRef
	mp4art --remove "$fileName"
	mp4art --add "$artworkFile" "$fileName"
	touch -r $timestampFileRef "$fileName" && \rm $timestampFileRef
	sync
}
function addThumbnail2mp4_AtomicParsley {
	test $# = 0 && {
		echo "=> Usage: $FUNCNAME artworkFile file" >&2
		return 1
	}

	local artworkFile="$1"
	local artworkExtension="${artworkFile/*./}"
	shift

	if ! file -b "$artworkFile" | \grep -q JPEG.*JFIF; then
		convert -verbose "$artworkFile" "${artworkFile/.*}_NEW.$artworkExtension" && mv -f "${artworkFile/.*}_NEW.$artworkExtension" "$artworkFile"
	fi

	local fileName="$1"
	local timestampFileRef=$(mktemp) && touch -r "$fileName" $timestampFileRef
	AtomicParsley "$fileName" --artwork "$artworkFile" --overWrite
	touch -r $timestampFileRef "$fileName" && \rm $timestampFileRef
	sync
}
function addURL2Audio_Video {
	local url=$1
	local fileName=$2
	local extension=${fileName/*./}
#	$ffmpeg -i "$fileName" -map 0 -c copy -metadata description="$url" "${fileName%.*}-NEW.$extension" && mv -vf "${fileName%.*}-NEW.$extension" $fileName
	[ $extension = mp4 ] || [ $extension = m4a ] && mp4tags -m "$url" "$fileName"
	sync
}
function any216kHzopus {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | sox -V -t wav - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2aac {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.aac"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -acodec aac -aprofile aac_low -q:a 1 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2aac_HE_AAC_VBR {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}_HE-AAC.aac"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he -vbr 1 "$outputFile"
			else
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he_v2 -vbr 1 "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2m4a {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.m4a"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -acodec aac -aprofile aac_low -q:a 1 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2m4a_HE_AAC_VBR {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}_HE-AAC.m4a"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he -vbr 1 "$outputFile"
			else
				time $ffmpeg -i "$inputFile" -vn -sn -acodec libfdk_aac -aprofile aac_he_v2 -vbr 1 "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus32kbps {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - --bitrate 32 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus42kbps {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - --bitrate 42 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2opus64kbps {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav - | opusenc - --bitrate 64 "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2wav {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile="${inputFile%.*}.wav"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -vn -sn -f wav "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function any2wavSTDOUT {
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>" >&2
		time $ffmpeg -i "$inputFile" -vn -sn -f wav -
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function audio2Video4YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME aacFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	local audioCodec=$(audioCodecOfFile "$audio" 2>/dev/null)
	local video4YouTubeFile
	case $audioCodec in
	aac)video4YouTubeFile="${audio%.*}__4YouTube.mp4"
		time $ffmpeg -i "$audio" -loop 1 -framerate 4 -i "$picture" -shortest -speed max -map 0:a -c:a copy -map 1:v -preset medium -tune stillimage -crf 18 -pix_fmt yuv420p -movflags +frag_keyframe "$video4YouTubeFile" #cf. https://trac.ffmpeg.org/wiki/Encode/YouTube
		;;
	opus|vorbis)video4YouTubeFile="${audio%.*}__4YouTube.webm"
		time $ffmpeg -i "$audio" -loop 1 -framerate 1 -i "$picture" -shortest -speed max -map 0:a -c:a copy -map 1:v "$video4YouTubeFile"
		;;
	*) echo "=> ERROR : $FUNCNAME : $audioCodec is not supported yet." >&2;return 1 ;;
	esac
	videoInfo "$video4YouTubeFile"
}
function audio2stout {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		$ffmpeg -i "$inputFile" -f wav -
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function audioChannelLayoutOfFile {
	local audioChannelLayout
	local ffprobeJSON_File_Info=null
	for file
	do
#		audioChannelLayout=$($ffprobe "$file" -select_streams a:0? -show_entries stream=channel_layout -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		audioChannelLayout=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="audio") ][-1].channel_layout')
		printf "=> $file : audioChannelLayout = " >&2
		echo $audioChannelLayout
	done
}
function audioCodecOfFile {
	local audioCodec
	local ffprobeJSON_File_Info=null
	for file
	do
#		audioCodec=$($ffprobe "$file" -select_streams a:0? -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		audioCodec=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="audio") ][-1].codec_name')
		printf "=> $file : audioCodec = " >&2
		echo $audioCodec
	done
}
function audioDelay {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME video delay" >&2
		return 1
	}

	local video=$1
	local delay=$2
	local extension=${video/*./}
	time $ffmpeg -i "$video" -itsoffset $delay -i "$video" -c copy -map 0:v -map 1:a "${video%.*}-FIXED.$extension" #cf. https://superuser.com/questions/982342/in-ffmpeg-how-to-delay-only-the-audio-of-a-mp4-video-without-converting-the-au/983153#983153
}
function audioShift {
	if [ $# != 2 ] && [ $# != 3 ]; then
		echo "=> Usage: $FUNCNAME <filename> hh:mm:ss[.xxx]"
		return 1
	fi

	fileName="$1"
	extension=${fileName/*./}
	fileBaseName=${fileName%.???}
	shift=$2
	time $ffmpeg -itsoffset $shift -i "$fileName" $remuxOptions "$fileBaseName-SHIFTED.$extension"
	sync
	touch -r "$fileName" "$fileBaseName-SHIFTED.$extension"
}
function avprobe {
	for arg
	do
		echo "$arg" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $avprobe $avprobeOptions "$(youtube-dl -gf best -- "$arg")" || command avprobe $avprobeOptions -probesize 400M -analyzeduration 400M "$arg"
#	done 2>&1 | cut -c 1-$(tput cols)
	done
}
function cropdetect {
	ffmpeg -i "$1" -t 1 -vf cropdetect -f null - 2>&1 | awk '/crop/{line=$NF}END{print line}'
}
function videoDVDInfo {
	cdr_device=/dev/dvd
	longestTrack=$(\lsdvd -Oy | awk -F ':|,| ' '/longest_track/{print$(NF-1)}')
	tccat -i $cdr_device -T $longestTrack,-1 2>/dev/null | $ffprobe - 2>&1
}
function ffprobeFileOrURL {
	which ffprobe >/dev/null && {
		for arg
		do
			echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
		done 2>&1
	}
}
function ffprobe2Flat {
	local ffprobeOptions="-v error -show_format -show_streams -of flat"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function ffprobe2Ini {
	local ffprobeOptions="-v error -show_format -show_streams -of ini"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function ffprobe2JSON {
	local ffprobeOptions="-v error -show_format -show_streams -of json"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function ffprobe2XML {
	local ffprobeOptions="-v error -show_format -show_streams -of xml"
	for arg
	do
		echo "$arg" | \egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://" && $ffprobe $ffprobeOptions "$(youtube-dl -gf best -- "$arg")" || $ffprobe $ffprobeOptions "$arg"
	done 2>&1 | cut -c 1-$(tput cols)
}
function flac2spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.flac/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
#			time sox -V "$inputFile" -r 16k $namedPipe norm &
#			time sox -V "$inputFile" $namedPipe rate 16k norm &
			time $ffmpeg -i "$inputFile" -ar 16k $namedPipe -y &
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr $namedPipe "$outputFile"
			time speexenc -V --quality 10 --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function frameCount {
	for video
	do
		echo "Video : $video"
		printf "Frames : "
		mediainfo --Inform="Video;%FrameCount%" "$video"
		echo
	done
}
function m3uConcat {
	files="$@"
	echo "#EXTM3U"
	egrep -hv "EXTM3U|^# *$" $files | dos2unix | egrep -v "^$"
}
function m4a2aac {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -acodec copy $@ "${file/.m4a/.aac}"
	for file
	do
		time $ffmpeg -i "$file" -acodec copy "${file/.m4a/.aac}"
		touch -r "$file" "${file/.m4a/.aac}"
		sync
	done
}
function mediainfoSummary {
	for media
	do
		mediainfo "$media"
		echo
	done | \egrep "^($|Complete name|Width|Height|Encoding settings|Format  |Format version|Format profile|Duration|Video|Audio|Text|Menu|Language)| size|Kbps|[Bb]it ?rate"
}
function mkv2ogg {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" -vn -acodec copy $@ "${file/.mkv/.ogg}"
	for file
	do
		time $ffmpeg -i "$file" -vn -acodec copy "${file/.mkv/.ogg}"
		touch -r "$file" "${file/.mkv/.ogg}"
		sync
	done
}
function mkvInfo {
#	file="$1"
#	shift
#	time time mkvinfo -s "$file" | grep Track
	for file
	do
		echo "=> file = $file" >&2
		echo >&2
		time mkvinfo -s "$file"
		echo >&2
	done | grep Track
}
function moov_atomFix {
	for inputFile
	do
		echo "=> inputFile = <$inputFile>" >&2
		outputFile="${inputFile/.mp4/_moov_atom_FIXED.mp4}"
		qtfaststart "$inputFile" "$outputFile" && touch -r "$inputFile" "$outputFile" && echo "=> outputFile = <$outputFile>" >&2
		sync
	done
}
function mp32opus {
#	file="$1"
#	shift
#	time $ffmpeg -i "$file" $@ "${file%.*}.opus"
	for file
	do
		time $ffmpeg -i "$file" "${file%.*}.opus"
		touch -r "$file" "${file%.*}.opus"
		sync
	done
}
function mp32spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		title=$(mp3info2 -p %t "$inputFile")
		echo "==> title = <$title>"
		album=$(mp3info -p %l "$inputFile")
		echo "==> album = <$album>"
#		artist=$(mp3info -p %a "$inputFile")

		outputFile=${inputFile/.mp3/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time sox -V "$inputFile" -t wav - channels 1 rate 16k norm | speexenc --title "$title" --comment ALBUM="$album" -V --vbr --quality 10 - "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp42mp4_HE_AAC_CBR {
#	local inputFile="$1"
for inputFile
do
	if [ -s "$inputFile" ]
	then
		echo "=> inputFile = <$inputFile>"
		outputFile=${inputFile/.mp4/_HE-AAC.mp4}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q Audio:.*mono
			then
				time $ffmpeg -i "$inputFile" $remuxOptions -acodec libfdk_aac -aprofile aac_he    -ab 64k $mp4Options "$outputFile"
			else
				time $ffmpeg -i "$inputFile" $remuxOptions -acodec libfdk_aac -aprofile aac_he_v2 -ab 64k $mp4Options "$outputFile"
			fi
			sync
			touch -r "$inputFile" "$outputFile"
			echo "=> outputFile = <$outputFile>"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			continue
		fi
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
done
}
function mp4DashAudio2aac {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.mp4/.aac}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp4DashAudio2m4a {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.mp4/.m4a}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function mp4Info {
	for file
	do
		echo "=> file = <$file>"
		AtomicParsley "$file" -T 1 | sed '/Movie duration/,$!d'
	done
}
function mp4Repair {
	for file
	do
		extension=mp4
		time $ffmpeg -i "$file" $remuxOptions $mp4Options "${file/.$extension/_REPAIRED.$extension}"
		sync
		touch -r "$file" "${file/.$extension/_REPAIRED.$extension}"
	done
}
function opus2WebM4YouTube {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME opusFile pictureFile" >&2
		return 1
	}

	local audio=$1
	local picture=$2
	time $ffmpeg -i "$audio" -loop 1 -framerate 1 -i "$picture" -shortest -speed max -c:a copy "${audio%.*}.webm"
}
function replaceAudioOfVideoFile {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME videoFile audioFile" >&2
		return 1
	}

	local videoFile="$1"
	local audioFile="$2"
	local extension="${videoFile/*./}"
	time $ffmpeg -i "$videoFile" -i "$audioFile" -map 0:v:0 -map 1:a:0 -c copy -shortest "${videoFile/.*/}_NEW.$extension"
	sync
}
function sizeOfStream {
	local size
	local totalExpr="0"
	local format=18

	if [ $# = 0 ];then
		echo "=> $FUNCNAME [format] url1 url2 ..." >&2
		return 1
	fi

	trap 'rc=130;set +x;echo "=> $FUNCNAME: CTRL+C Interruption trapped.">&2;return $rc' INT

	echo $1 | \grep -q ^http || {
		format=$1
		shift
	}

	for url
	do
		size=$(curl -sI "$(youtube-dl -gf $format -- "$url")" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1}/Content-Length:/{print$2/2^20}')
		totalExpr="$totalExpr+$size"
		echo "$url $size Mo"
	done
	total=$(perl -e "printf $totalExpr")
	echo "=> total = $total Mo"

	trap - INT
}
function spx216kHzopus {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if [ $(audioChannelLayoutOfFile "$inputFile" 2>/dev/null) = stereo ]
			then
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 2 - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			else
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 1 - -t wav - channels 1 rate 16k norm | opusenc - "$outputFile"
			fi
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function spx216kHzspx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.oga/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			if $ffprobe "$inputFile" 2>&1 | grep -q stereo
			then
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 2 - -t wav - channels 1 rate 16k norm | speexenc -V --quality 10 --vbr - "$outputFile"
			else
				time speexdec -V "$inputFile" - | sox -t raw -V -b 16 -e signed -r 44.1k -c 1 - -t wav - channels 1 rate 16k norm | speexenc -V --quality 10 --vbr - "$outputFile"
			fi
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function spx2opus {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			#freq=$(mediainfo --Inform="Audio;%SamplingRate%" "$inputFile")
			time audio2stout "$inputFile" | opusenc - "$outputFile"
			touch -r "$inputFile" "$outputFile"
			sync
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function to16_9 {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -aspect 16/9 $remuxOptions "${video/.$extension/_16_9eme.$extension}"
	done
}
function urlOfVideo {
	local extension
	for video
	do
		extension="${video/*./}"
		case $extension in
		mp4|m4a|m4b|m4v) tag=description;;
		webm|mkv) tag=purl;;
		*) echo "=> The $extension is not supported yet." >&2 && continue;;
		esac
		echo "=> video = $video"
		$ffprobe -v error -show_entries format_tags=$tag -of default=noprint_wrappers=1:nokey=1 "$video"
	done
}
function urlinfo {
	for url
	do
		echo "=> url = $url"
		$ffprobe $(youtube-dl -gf best -- "$url")
	done
}
function subtitleCodecOfFile {
	local subtitleCodec
	local ffprobeJSON_File_Info=null
	for file
	do
#		subtitleCodec=$($ffprobe "$file" -select_streams s:0? -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		subtitleCodec=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="subtitle") ][-1].codec_name')
		printf "=> $file : subtitleCodec = " >&2
		echo $subtitleCodec
	done
}
function videoCodecOfFile {
	local videoCodec
	local ffprobeJSON_File_Info=null
	for file
	do
#		videoCodec=$($ffprobe "$file" -select_streams v:0? -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		videoCodec=$(echo $ffprobeJSON_File_Info | jq -r '[ .streams[] | select(.codec_type=="video") ][-1].codec_name')
		printf "=> $file : videoCodec = " >&2
		echo $videoCodec
	done
}
function containerOfFile {
	local container
	local ffprobeJSON_File_Info=null
	for file
	do
#		container=$($ffprobe "$file" -show_entries format=format_name -of default=noprint_wrappers=1:nokey=1 -v error)
		ffprobeJSON_File_Info=$($ffprobe -v error -show_format -show_streams -print_format json "$file")
		container=$(echo $ffprobeJSON_File_Info | jq -r .format.format_name | cut -d, -f1)
		printf "=> $file : container = " >&2
		echo $container
	done
}
function videoDelay {
	test $# -ne 2 && {
		echo "=> Usage: $FUNCNAME video delay" >&2
		return 1
	}

	local video=$1
	local delay=$2
	local extension=${video/*./}
	time $ffmpeg -i "$video" -itsoffset $delay -i "$video" -c copy -map 1:v -map 0:a "${video%.*}-FIXED.$extension" #cf. https://superuser.com/questions/982342/in-ffmpeg-how-to-delay-only-the-audio-of-a-mp4-video-without-converting-the-au/983153#983153
}
function videoGet {
	ls "$@" >/dev/null || return
	for file
	do
		extension=${file/*./}
		videoFormat=$(ffprobe "$file" 2>&1 | grep -v Video:.mjpeg | awk '/Video/{print$4}' | sed "s/,$//")
		outputExtension=${videoExtension[$videoFormat]}
		outputFileName=${file/.$extension/_VIDEO.$outputExtension}
		outputFileName=$(echo $outputFileName | cut -d/ -f3-) # Remove the two leading directories from the path
		minimumVideoStreamSize=$(mediainfo --Output="Video;%StreamSize%" "$file") || return
		if test -s "$outputFileName" && [ $(stat -c '%s' "$outputFileName") -ge $minimumVideoStreamSize ]
		then
			echo "=> INFO: The file $file has already been converted to $outputFileName." >&2
			continue
		fi
		\mkdir -pv $(dirname $outputFileName)
		time $ffmpeg -i "$file" -an -codec copy $options "$outputFileName" -y
		touch -r "$file" "$outputFileName"
		sync
		echo
		test -s "$outputFileName" && echo "=> Output file is: <$outputFileName>."
	done
}
function videoInfo {
	local columns=$(tput cols)
#	local columns="" # To see more info than the width of the screen
	local size=0
	which ffprobe >/dev/null && {
		for urlOrFile
		do
			echo "=> urlOrFile = $urlOrFile"
			if echo "$urlOrFile" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://"
			then
				#remote stream
				if \curl -s "$urlOrFile" | file -bi - | \grep -q "^text/"
				then
					#undirect stream
					echo "=> This stream needs first to be resolved by youtube-dl ..."
					possibleFormats=best[ext=mp4]/best[ext=webm]/best[ext=flv]/18/webm/sd/http-480
					infos="$(youtube-dl -gef $possibleFormats -- "$urlOrFile")"
					test -z "$infos" && continue
					title="$(echo "$infos" | sed -n 1p )"
					directURLOfStream="$(echo "$infos" | sed -n 2p | sed "s/ /%20/g")"
					size=$(\curl -sI "$directURLOfStream" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Title: $title"
					echo "Size: $size"
					$ffprobe $ffprobeOptions "$directURLOfStream" 2>&1
				else
					#direct stream
					echo "=> This stream is direct stream"
					size=$(\curl -sI "$urlOrFile" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Size: $size"
					$ffprobe "$urlOrFile"
				fi
			else
				echo "=> The file is local to this machine."
				#Local file
				size=$(\stat -c %s "$urlOrFile" | awk '/[0-9]+/{printf "%8.3f MiB\n",$1/1024^2}')
				echo "Size: $size"
				$ffprobe "$urlOrFile" || $ffprobe $ffprobeOptions "$urlOrFile"
			fi
			echo
		done 2>&1 | \egrep -vi "^ +(:|comment|description +: [^/]+$)" | uniq | egrep -iw "^$|description.*:/|PURL.*:/|stream|local|urlOrFile|[0-9]+ kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not "
	}
}
function videoInfoOLD {
	local columns=$(tput cols)
#	local columns="" # To see more info than the width of the screen
	local size=0
	which ffprobe >/dev/null && {
		for urlOrFile
		do
			echo "=> urlOrFile = $urlOrFile"
			if echo "$urlOrFile" | egrep -q "(https?|s?ftps?|ssh|rtmp|rtsp|mms)://"
			then
				#remote stream
				if \curl -s "$urlOrFile" | file -bi - | \grep -q "^text/"
				then
					echo "=> This stream needs first to be resolved by youtube-dl ..."
					possibleFormats=best[ext=mp4]/best[ext=webm]/best[ext=flv]/18/webm/sd/http-480
					infos="$(youtube-dl -gef $possibleFormats -- "$urlOrFile")"
					test -z "$infos" && continue
					title="$(echo "$infos" | sed -n 1p )"
					directURLOfStream="$(echo "$infos" | sed -n 2p)"
					size=$(\curl -sI "$directURLOfStream" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Title: $title"
					echo "Size: $size"
					command ffprobe $ffprobeOptions "$directURLOfStream" 2>&1
				else
					#direct stream
					echo "=> This stream is direct stream"
					size=$(\curl -sI "$urlOrFile" | \sed "s/\r//g" | awk 'BEGIN{IGNORECASE=1;size=0}/Content-Length:/{if($2>0)size=$2}END{printf "%8.3f MiB\n",size/2^20}')
					echo "Size: $size"
					$ffprobe "$urlOrFile"
				fi
			else
				echo "=> The file is local to this machine."
				#Local file
				size=$(\ls -l "$urlOrFile" | awk '/[0-9]+/{printf "%8.3f MiB\n",$5/1024^2}')
				echo "Size: $size"
				$ffprobe "$urlOrFile" || $ffprobe $ffprobeOptions "$urlOrFile"
			fi
			echo
#		done 2>&1 | cut -c 1-$columns | \egrep -iw "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not" | uniq | \egrep -iw --color "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
		done 2>&1 | \egrep -iw "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not" | uniq | \egrep -iw --color "^$|stream|local|urlOrFile|kb/s|Input|Size:|Title:|Duration:|Stream|Chapter|Invalid|error|bad| no such file|^\[.* not"
	}
}
function videoRemoveMetaData {
	local extension videoBaseName outputVideo
	for video
	do
		extension="${video/*./}"
#		videoBaseName="${video%.???}"
		outputVideo="${video/.$extension/-NoMetaData.$extension}"
		echo "=> Processing = $video ..." >&2
		$ffmpeg -i "$video" -map 0:v:0? -map 0:a? -map 0:s? -c copy -map_metadata:g -1 "$outputVideo"
		test $? = 0 && {
			touch -r "$video" "$outputVideo"
			sync
			echo >&2
			$ffprobe "$outputVideo"
		}
	done
}
function videoRemux {
	local inputFile="$1"
	if [ $# != 2 ]
	then
		echo "=> Usage: $FUNCNAME inputFileName outputFileName [ffmpegCLIParameters]" >&2
		return 1
	fi

	shift
	outputFile="$1"
	outputExtension=${outputFile/*./}
	local options
	case $outputExtension in
		vob) options="-f mpeg" ;;
		*) options="" ;;
	esac

	time $ffmpeg -i "$inputFile" $remuxOptions $options "$@"
	sync
	touch -r "$inputFile" "$outputFile"
}
function videoRepair {
	for file
	do
		extension="${file/*./}"
		time $ffmpeg -i "$file" $remuxOptions "${file/.$extension/_REPAIRED.$extension}"
		sync
		touch -r "$file" "${file/.$extension/_REPAIRED.$extension}"
	done
}
function videoRotateLeft {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -map 0 -c copy -metadata:s:v:0 rotate=90 "${video%.*}-ROTATED.$extension"
	done
}
function videoRotateRight {
	local extension
	for video
	do
		extension=${video/*./}
		$ffmpeg -i "$video" -map 0 -c copy -metadata:s:v:0 rotate=-90 "${video%.*}-ROTATED.$extension"
	done
}
function videoSplit {
	if [ $# != 2 ] && [ $# != 3 ]
	then
		echo "=> Usage: $FUNCNAME <filename> hh:mm:ss[.xxx] [ hh:mm:ss[.xxx] ]" >&2
		return 1
	fi

	fileName="$1"
	test -r "$fileName" || {
		echo "=> ERROR: <$fileName> cannot be read by $USER or does not exist." >&2
		return 2
	}

	extension=${fileName/*./}
	fileBaseName=${fileName%.???}
	begin=$2
	outputFile="$fileBaseName-CUT.$extension"
	chmod -x "$fileName"

#	[ $extension = mp4 ] && remuxOptions="$remuxOptions $mp4Options"
	if test $# = 3
	then
		end=$3
		duration=$(echo $(date +%s.%N -d $end) - $(date +%s.%N -d $begin) | bc -l)
		set -x
		time $ffmpeg -ss $begin -t $duration -i "$fileName" $remuxOptions "$outputFile"
	else
		set -x
		time $ffmpeg -ss $begin -i "$fileName" $remuxOptions "$outputFile"
	fi
	set +x
	sync
	touch -r "$fileName" "$outputFile"
	echo "=> outputFile = <$outputFile>"
}
function videoURL {
	for video
	do
		printf "$video : "
		$ffprobe "$video" 2>&1 | awk '/PURL|description/{print$3;exit;}'
	done
}
function vlcRecord {
	local file=vlc-record-$(date +"%Y-%m-%d-%Hh%Mm%Ss")-$(echo $1 | tr "[:/]" "_" ).ts
	echo "=> The recording will be saved into the file: <$file>"
	cvlc --verbose=1 --ipv4-timeout=600  --logmode=text --log-verbose=-1 --logfile=vlcrecord_$(date +"%Y-%m-%d-%Hh%Mm%Ss").out --sout=file:$file $1
	echo "=> The recording is saved into the file: <$file>" >&2
}
function wav16k2spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile=${inputFile/.wav/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr "$inputFile" "$outputFile"
			time speexenc -V --quality 10 --vbr "$inputFile" "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav216kHz {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_16k.wav}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
#			time sox -V "$inputFile" "$outputFile" rate 16k norm
			time $ffmpeg -i "$inputFile" -ar 16k "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav216kwav {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_16kHz.wav}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" -ar 16k "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav2opus {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
#		title=$(mp3info -p %t "$inputFile")
#		echo "==> title = <$title>"
#		album=$(mp3info -p %l "$inputFile")
#		echo "==> album = <$album>"
#		   artist=$(mp3info -p %a "$inputFile")

		outputFile="${inputFile%.*}.opus"
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
			time sox -V "$inputFile" $namedPipe rate 16k norm &
#			time opusenc --title "$title" --album ALBUM="$album" --vbr $namedPipe "$outputFile"
			time opusenc --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function wav2spx {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.wav/_speex.oga}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			namedPipe=$(mktemp -u).wav
			mkfifo $namedPipe
#			time sox -V "$inputFile" -r 16k $namedPipe norm &
			time sox -V "$inputFile" $namedPipe rate 16k norm &
#			time speexenc --title "$title" --comment ALBUM="$album" -V --quality 10 --vbr $namedPipe "$outputFile"
			time speexenc -V --quality 10 --vbr $namedPipe "$outputFile"
			\rm $namedPipe
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}
function webmAudio2ogg {
	typeset inputFile="$1"
	if [ -s "$inputFile" ]
	then
		outputFile=${inputFile/.webm/.ogg}
		echo "==> outputFile = $outputFile"
		if [ ! -s "$outputFile" ]
		then
			time $ffmpeg -i "$inputFile" $remuxOptions "$outputFile"
			sync
			touch -r "$inputFile" "$outputFile"
		else
			echo "=> ERROR: The file <$outputFile> already exits." >&2
			return 1
		fi
		echo "=> outputFile = <$outputFile>"
	else
		echo "=> ERROR: The file <$inputFile> does not exit or is empty." >&2
	fi
}

set +x
test "$debug" -gt 0 && echo "=> END of $bold${colors[blue]}$(basename ${BASH_SOURCE[0]})$normal"
